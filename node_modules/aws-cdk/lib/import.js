"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceImporter = void 0;
const cfnDiff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const fs = require("fs-extra");
const promptly = require("promptly");
const logging_1 = require("./logging");
/**
 * Resource importing utility class
 *
 * - Determines the resources added to a template (compared to the deployed version)
 * - Look up the identification information
 *   - Load them from a file, or
 *   - Ask the user, based on information supplied to us by CloudFormation's GetTemplateSummary
 * - Translate the input to a structure expected by CloudFormation, update the template to add the
 *   importable resources, then run an IMPORT changeset.
 */
class ResourceImporter {
    constructor(stack, cfn, options = {}) {
        this.stack = stack;
        this.cfn = cfn;
        this.options = options;
    }
    /**
     * Ask the user for resources to import
     */
    async askForResourceIdentifiers(available) {
        const ret = { importResources: [], resourceMap: {} };
        const resourceIdentifiers = await this.resourceIdentifiers();
        for (const resource of available) {
            const identifier = await this.askForResourceIdentifier(resourceIdentifiers, resource);
            if (!identifier) {
                continue;
            }
            ret.importResources.push(resource);
            ret.resourceMap[resource.logicalId] = identifier;
        }
        return ret;
    }
    /**
     * Load the resources to import from a file
     */
    async loadResourceIdentifiers(available, filename) {
        const contents = await fs.readJson(filename);
        const ret = { importResources: [], resourceMap: {} };
        for (const resource of available) {
            const descr = this.describeResource(resource.logicalId);
            const idProps = contents[resource.logicalId];
            if (idProps) {
                (0, logging_1.print)('%s: importing using %s', chalk.blue(descr), chalk.blue(fmtdict(idProps)));
                ret.importResources.push(resource);
                ret.resourceMap[resource.logicalId] = idProps;
                delete contents[resource.logicalId];
            }
            else {
                (0, logging_1.print)('%s: skipping', chalk.blue(descr));
            }
        }
        const unknown = Object.keys(contents);
        if (unknown.length > 0) {
            (0, logging_1.warning)(`Unrecognized resource identifiers in mapping file: ${unknown.join(', ')}`);
        }
        return ret;
    }
    /**
     * Based on the provided resource mapping, prepare CFN structures for import (template,
     * ResourcesToImport structure) and perform the import operation (CloudFormation deployment)
     *
     * @param importMap Mapping from CDK construct tree path to physical resource import identifiers
     * @param options Options to pass to CloudFormation deploy operation
     */
    async importResources(importMap, options) {
        const resourcesToImport = await this.makeResourcesToImport(importMap);
        const updatedTemplate = await this.currentTemplateWithAdditions(importMap.importResources);
        try {
            const result = await this.cfn.deployStack({
                ...options,
                overrideTemplate: updatedTemplate,
                resourcesToImport,
            });
            const message = result.noOp
                ? ' ✅  %s (no changes)'
                : ' ✅  %s';
            (0, logging_1.success)('\n' + message, options.stack.displayName);
        }
        catch (e) {
            (0, logging_1.error)('\n ❌  %s failed: %s', chalk.bold(options.stack.displayName), e);
            throw e;
        }
    }
    /**
     * Perform a diff between the currently running and the new template, ensure that it is valid
     * for importing and return a list of resources that are being added in the new version
     *
     * @return mapping logicalResourceId -> resourceDifference
     */
    async discoverImportableResources(allowNonAdditions = false) {
        const currentTemplate = await this.currentTemplate();
        const diff = cfnDiff.diffTemplate(currentTemplate, this.stack.template);
        // Ignore changes to CDKMetadata
        const resourceChanges = Object.entries(diff.resources.changes)
            .filter(([logicalId, _]) => logicalId !== 'CDKMetadata');
        // Split the changes into additions and non-additions. Imports only make sense
        // for newly-added resources.
        const nonAdditions = resourceChanges.filter(([_, dif]) => !dif.isAddition);
        const additions = resourceChanges.filter(([_, dif]) => dif.isAddition);
        if (nonAdditions.length) {
            const offendingResources = nonAdditions.map(([logId, _]) => this.describeResource(logId));
            if (allowNonAdditions) {
                (0, logging_1.warning)(`Ignoring updated/deleted resources (--force): ${offendingResources.join(', ')}`);
            }
            else {
                throw new Error('No resource updates or deletes are allowed on import operation. Make sure to resolve pending changes ' +
                    `to existing resources, before attempting an import. Updated/deleted resources: ${offendingResources.join(', ')} (--force to override)`);
            }
        }
        // Resources in the new template, that are not present in the current template, are a potential import candidates
        return {
            additions: additions.map(([logicalId, resourceDiff]) => ({
                logicalId,
                resourceDiff,
                resourceDefinition: addDefaultDeletionPolicy(this.stack.template?.Resources?.[logicalId] ?? {}),
            })),
            hasNonAdditions: nonAdditions.length > 0,
        };
    }
    /**
     * Get currently deployed template of the given stack (SINGLETON)
     *
     * @returns Currently deployed CloudFormation template
     */
    async currentTemplate() {
        if (!this._currentTemplate) {
            this._currentTemplate = await this.cfn.readCurrentTemplate(this.stack);
        }
        return this._currentTemplate;
    }
    /**
     * Return the current template, with the given resources added to it
     */
    async currentTemplateWithAdditions(additions) {
        const template = await this.currentTemplate();
        if (!template.Resources) {
            template.Resources = {};
        }
        for (const add of additions) {
            template.Resources[add.logicalId] = add.resourceDefinition;
        }
        return template;
    }
    /**
     * Get a list of import identifiers for all resource types used in the given
     * template that do support the import operation (SINGLETON)
     *
     * @returns a mapping from a resource type to a list of property names that together identify the resource for import
     */
    async resourceIdentifiers() {
        const ret = {};
        const resourceIdentifierSummaries = await this.cfn.resourceIdentifierSummaries(this.stack, this.options.toolkitStackName);
        for (const summary of resourceIdentifierSummaries) {
            if ('ResourceType' in summary && summary.ResourceType && 'ResourceIdentifiers' in summary && summary.ResourceIdentifiers) {
                ret[summary.ResourceType] = (summary.ResourceIdentifiers ?? [])?.map(x => x.split(','));
            }
        }
        return ret;
    }
    /**
     * Ask for the importable identifier for the given resource
     *
     * There may be more than one identifier under which a resource can be imported. The `import`
     * operation needs exactly one of them.
     *
     * - If we can get one from the template, we will use one.
     * - Otherwise, we will ask the user for one of them.
     */
    async askForResourceIdentifier(resourceIdentifiers, chg) {
        const resourceName = this.describeResource(chg.logicalId);
        // Skip resources that do not support importing
        const resourceType = chg.resourceDiff.newResourceType;
        if (resourceType === undefined || !(resourceType in resourceIdentifiers)) {
            (0, logging_1.warning)(`${resourceName}: unsupported resource type ${resourceType}, skipping import.`);
            return undefined;
        }
        const idPropSets = resourceIdentifiers[resourceType];
        // Retain only literal strings: strip potential CFN intrinsics
        const resourceProps = Object.fromEntries(Object.entries(chg.resourceDefinition.Properties ?? {})
            .filter(([_, v]) => typeof v === 'string'));
        // Find property sets that are fully satisfied in the template, ask the user to confirm them
        const satisfiedPropSets = idPropSets.filter(ps => ps.every(p => resourceProps[p]));
        for (const satisfiedPropSet of satisfiedPropSets) {
            const candidateProps = Object.fromEntries(satisfiedPropSet.map(p => [p, resourceProps[p]]));
            const displayCandidateProps = fmtdict(candidateProps);
            if (await promptly.confirm(`${chalk.blue(resourceName)} (${resourceType}): import with ${chalk.yellow(displayCandidateProps)} (yes/no) [default: yes]? `, { default: 'yes' })) {
                return candidateProps;
            }
        }
        // If we got here and the user rejected any available identifiers, then apparently they don't want the resource at all
        if (satisfiedPropSets.length > 0) {
            (0, logging_1.print)(chalk.grey(`Skipping import of ${resourceName}`));
            return undefined;
        }
        // We cannot auto-import this, ask the user for one of the props
        // The only difference between these cases is what we print: for multiple properties, we print a preamble
        const prefix = `${chalk.blue(resourceName)} (${resourceType})`;
        let preamble;
        let promptPattern;
        if (idPropSets.length > 1) {
            preamble = `${prefix}: enter one of ${idPropSets.map(x => chalk.blue(x.join('+'))).join(', ')} to import (all empty to skip)`;
            promptPattern = `${prefix}: enter %`;
        }
        else {
            promptPattern = `${prefix}: enter %`;
        }
        // Do the input loop here
        if (preamble) {
            (0, logging_1.print)(preamble);
        }
        for (const idProps of idPropSets) {
            const input = {};
            for (const idProp of idProps) {
                // If we have a value from the template, use it as default. This will only be a partial
                // identifier if present, otherwise we would have done the import already above.
                const defaultValue = typeof resourceProps[idProp] ?? '';
                const prompt = [
                    promptPattern.replace(/%/, chalk.blue(idProp)),
                    defaultValue
                        ? `[${defaultValue}]`
                        : '(empty to skip)',
                ].join(' ') + ':';
                const response = await promptly.prompt(prompt, { default: defaultValue, trim: true });
                if (!response) {
                    break;
                }
                input[idProp] = response;
                // Also stick this property into 'resourceProps', so that it may be reused by a subsequent question
                // (for a different compound identifier that involves the same property). Just a small UX enhancement.
                resourceProps[idProp] = response;
            }
            // If the user gave inputs for all values, we are complete
            if (Object.keys(input).length === idProps.length) {
                return input;
            }
        }
        (0, logging_1.print)(chalk.grey(`Skipping import of ${resourceName}`));
        return undefined;
    }
    /**
     * Convert the internal "resource mapping" structure to CloudFormation accepted "ResourcesToImport" structure
     */
    async makeResourcesToImport(resourceMap) {
        return resourceMap.importResources.map(res => ({
            LogicalResourceId: res.logicalId,
            ResourceType: res.resourceDiff.newResourceType,
            ResourceIdentifier: resourceMap.resourceMap[res.logicalId],
        }));
    }
    /**
     * Convert CloudFormation logical resource ID to CDK construct tree path
     *
     * @param logicalId CloudFormation logical ID of the resource (the key in the template's Resources section)
     * @returns Forward-slash separated path of the resource in CDK construct tree, e.g. MyStack/MyBucket/Resource
     */
    describeResource(logicalId) {
        return this.stack.template?.Resources?.[logicalId]?.Metadata?.['aws:cdk:path'] ?? logicalId;
    }
}
exports.ResourceImporter = ResourceImporter;
function fmtdict(xs) {
    return Object.entries(xs).map(([k, v]) => `${k}=${v}`).join(', ');
}
/**
 * Add a default `DeletionPolicy` policy.
 * The default value is set to 'Retain', to lower risk of unintentionally
 * deleting stateful resources in the process of importing to CDK.
 */
function addDefaultDeletionPolicy(resource) {
    if (resource.DeletionPolicy) {
        return resource;
    }
    return {
        ...resource,
        DeletionPolicy: 'Retain',
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1wb3J0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiaW1wb3J0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHdEQUF3RDtBQUd4RCwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLHFDQUFxQztBQUdyQyx1Q0FBMkQ7QUEwQzNEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQWEsZ0JBQWdCO0lBRzNCLFlBQ21CLEtBQXdDLEVBQ3hDLEdBQThCLEVBQzlCLFVBQW1DLEVBQUU7UUFGckMsVUFBSyxHQUFMLEtBQUssQ0FBbUM7UUFDeEMsUUFBRyxHQUFILEdBQUcsQ0FBMkI7UUFDOUIsWUFBTyxHQUFQLE9BQU8sQ0FBOEI7SUFBSSxDQUFDO0lBRTdEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLHlCQUF5QixDQUFDLFNBQStCO1FBQ3BFLE1BQU0sR0FBRyxHQUFjLEVBQUUsZUFBZSxFQUFFLEVBQUUsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFLENBQUM7UUFDaEUsTUFBTSxtQkFBbUIsR0FBRyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1FBRTdELEtBQUssTUFBTSxRQUFRLElBQUksU0FBUyxFQUFFO1lBQ2hDLE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3RGLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2YsU0FBUzthQUNWO1lBRUQsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDbkMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsVUFBVSxDQUFDO1NBQ2xEO1FBRUQsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7SUFDSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsU0FBK0IsRUFBRSxRQUFnQjtRQUNwRixNQUFNLFFBQVEsR0FBRyxNQUFNLEVBQUUsQ0FBQyxR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QUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDcEUsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFTLHdCQUF3QixDQUFDLFFBQWE7SUFDN0MsSUFBSSxRQUFRLENBQUMsY0FBYyxFQUFFO1FBQUUsT0FBTyxRQUFRLENBQUM7S0FBRTtJQUVqRCxPQUFPO1FBQ0wsR0FBRyxRQUFRO1FBQ1gsY0FBYyxFQUFFLFFBQVE7S0FDekIsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZm5EaWZmIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0IHsgUmVzb3VyY2VEaWZmZXJlbmNlIH0gZnJvbSAnQGF3cy1jZGsvY2xvdWRmb3JtYXRpb24tZGlmZic7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcHJvbXB0bHkgZnJvbSAncHJvbXB0bHknO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb25EZXBsb3ltZW50cywgRGVwbG95U3RhY2tPcHRpb25zIH0gZnJvbSAnLi9hcGkvY2xvdWRmb3JtYXRpb24tZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgUmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcywgUmVzb3VyY2VzVG9JbXBvcnQgfSBmcm9tICcuL2FwaS91dGlsL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IGVycm9yLCBwcmludCwgc3VjY2Vzcywgd2FybmluZyB9IGZyb20gJy4vbG9nZ2luZyc7XG5cbi8qKlxuICogU2V0IG9mIHBhcmFtZXRlcnMgdGhhdCB1bmlxdWVseSBpZGVudGlmeSBhIHBoeXNpY2FsIHJlc291cmNlIG9mIGEgZ2l2ZW4gdHlwZVxuICogZm9yIHRoZSBpbXBvcnQgb3BlcmF0aW9uLCBleGFtcGxlOlxuICpcbiAqIGBgYFxuICoge1xuICogICBcIkFXUzo6UzM6OkJ1Y2tldFwiOiBbW1wiQnVja2V0TmFtZVwiXV0sXG4gKiAgIFwiQVdTOjpEeW5hbW9EQjo6R2xvYmFsVGFibGVcIjogW1tcIlRhYmxlTmFtZVwiXSwgW1wiVGFibGVBcm5cIl0sIFtcIlRhYmxlU3RyZWFtQXJuXCJdXSxcbiAqICAgXCJBV1M6OlJvdXRlNTM6OktleVNpZ25pbmdLZXlcIjogW1tcIkhvc3RlZFpvbmVJZFwiLCBcIk5hbWVcIl1dLFxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCB0eXBlIFJlc291cmNlSWRlbnRpZmllcnMgPSB7IFtyZXNvdXJjZVR5cGU6IHN0cmluZ106IHN0cmluZ1tdW10gfTtcblxuLyoqXG4gKiBNYXBwaW5nIG9mIENESyByZXNvdXJjZXMgKEwxIGNvbnN0cnVjdHMpIHRvIHBoeXNpY2FsIHJlc291cmNlcyB0byBiZSBpbXBvcnRlZFxuICogaW4gdGhlaXIgcGxhY2UsIGV4YW1wbGU6XG4gKlxuICogYGBgXG4gKiB7XG4gKiAgIFwiTXlTdGFjay9NeVMzQnVja2V0L1Jlc291cmNlXCI6IHtcbiAqICAgICBcIkJ1Y2tldE5hbWVcIjogXCJteS1tYW51YWxseS1jcmVhdGVkLXMzLWJ1Y2tldFwiXG4gKiAgIH0sXG4gKiAgIFwiTXlTdGFjay9NeVZwYy9SZXNvdXJjZVwiOiB7XG4gKiAgICAgXCJWcGNJZFwiOiBcInZwYy0xMjM0NTY3ODlcIlxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHR5cGUgUmVzb3VyY2VNYXAgPSB7IFtsb2dpY2FsUmVzb3VyY2U6IHN0cmluZ106IFJlc291cmNlSWRlbnRpZmllclByb3BlcnRpZXMgfTtcblxuZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZUltcG9ydGVyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRvb2xraXQgc3RhY2sgaWYgbm9uLWRlZmF1bHRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0IHRvb2xraXQgc3RhY2sgbmFtZVxuICAgKi9cbiAgcmVhZG9ubHkgdG9vbGtpdFN0YWNrTmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXNvdXJjZSBpbXBvcnRpbmcgdXRpbGl0eSBjbGFzc1xuICpcbiAqIC0gRGV0ZXJtaW5lcyB0aGUgcmVzb3VyY2VzIGFkZGVkIHRvIGEgdGVtcGxhdGUgKGNvbXBhcmVkIHRvIHRoZSBkZXBsb3llZCB2ZXJzaW9uKVxuICogLSBMb29rIHVwIHRoZSBpZGVudGlmaWNhdGlvbiBpbmZvcm1hdGlvblxuICogICAtIExvYWQgdGhlbSBmcm9tIGEgZmlsZSwgb3JcbiAqICAgLSBBc2sgdGhlIHVzZXIsIGJhc2VkIG9uIGluZm9ybWF0aW9uIHN1cHBsaWVkIHRvIHVzIGJ5IENsb3VkRm9ybWF0aW9uJ3MgR2V0VGVtcGxhdGVTdW1tYXJ5XG4gKiAtIFRyYW5zbGF0ZSB0aGUgaW5wdXQgdG8gYSBzdHJ1Y3R1cmUgZXhwZWN0ZWQgYnkgQ2xvdWRGb3JtYXRpb24sIHVwZGF0ZSB0aGUgdGVtcGxhdGUgdG8gYWRkIHRoZVxuICogICBpbXBvcnRhYmxlIHJlc291cmNlcywgdGhlbiBydW4gYW4gSU1QT1JUIGNoYW5nZXNldC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlc291cmNlSW1wb3J0ZXIge1xuICBwcml2YXRlIF9jdXJyZW50VGVtcGxhdGU6IGFueTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjZm46IENsb3VkRm9ybWF0aW9uRGVwbG95bWVudHMsXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBSZXNvdXJjZUltcG9ydGVyT3B0aW9ucyA9IHt9KSB7IH1cblxuICAvKipcbiAgICogQXNrIHRoZSB1c2VyIGZvciByZXNvdXJjZXMgdG8gaW1wb3J0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYXNrRm9yUmVzb3VyY2VJZGVudGlmaWVycyhhdmFpbGFibGU6IEltcG9ydGFibGVSZXNvdXJjZVtdKTogUHJvbWlzZTxJbXBvcnRNYXA+IHtcbiAgICBjb25zdCByZXQ6IEltcG9ydE1hcCA9IHsgaW1wb3J0UmVzb3VyY2VzOiBbXSwgcmVzb3VyY2VNYXA6IHt9IH07XG4gICAgY29uc3QgcmVzb3VyY2VJZGVudGlmaWVycyA9IGF3YWl0IHRoaXMucmVzb3VyY2VJZGVudGlmaWVycygpO1xuXG4gICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiBhdmFpbGFibGUpIHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBhd2FpdCB0aGlzLmFza0ZvclJlc291cmNlSWRlbnRpZmllcihyZXNvdXJjZUlkZW50aWZpZXJzLCByZXNvdXJjZSk7XG4gICAgICBpZiAoIWlkZW50aWZpZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldC5pbXBvcnRSZXNvdXJjZXMucHVzaChyZXNvdXJjZSk7XG4gICAgICByZXQucmVzb3VyY2VNYXBbcmVzb3VyY2UubG9naWNhbElkXSA9IGlkZW50aWZpZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSByZXNvdXJjZXMgdG8gaW1wb3J0IGZyb20gYSBmaWxlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbG9hZFJlc291cmNlSWRlbnRpZmllcnMoYXZhaWxhYmxlOiBJbXBvcnRhYmxlUmVzb3VyY2VbXSwgZmlsZW5hbWU6IHN0cmluZyk6IFByb21pc2U8SW1wb3J0TWFwPiB7XG4gICAgY29uc3QgY29udGVudHMgPSBhd2FpdCBmcy5yZWFkSnNvbihmaWxlbmFtZSk7XG5cbiAgICBjb25zdCByZXQ6IEltcG9ydE1hcCA9IHsgaW1wb3J0UmVzb3VyY2VzOiBbXSwgcmVzb3VyY2VNYXA6IHt9IH07XG4gICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiBhdmFpbGFibGUpIHtcbiAgICAgIGNvbnN0IGRlc2NyID0gdGhpcy5kZXNjcmliZVJlc291cmNlKHJlc291cmNlLmxvZ2ljYWxJZCk7XG4gICAgICBjb25zdCBpZFByb3BzID0gY29udGVudHNbcmVzb3VyY2UubG9naWNhbElkXTtcbiAgICAgIGlmIChpZFByb3BzKSB7XG4gICAgICAgIHByaW50KCclczogaW1wb3J0aW5nIHVzaW5nICVzJywgY2hhbGsuYmx1ZShkZXNjciksIGNoYWxrLmJsdWUoZm10ZGljdChpZFByb3BzKSkpO1xuXG4gICAgICAgIHJldC5pbXBvcnRSZXNvdXJjZXMucHVzaChyZXNvdXJjZSk7XG4gICAgICAgIHJldC5yZXNvdXJjZU1hcFtyZXNvdXJjZS5sb2dpY2FsSWRdID0gaWRQcm9wcztcbiAgICAgICAgZGVsZXRlIGNvbnRlbnRzW3Jlc291cmNlLmxvZ2ljYWxJZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmludCgnJXM6IHNraXBwaW5nJywgY2hhbGsuYmx1ZShkZXNjcikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHVua25vd24gPSBPYmplY3Qua2V5cyhjb250ZW50cyk7XG4gICAgaWYgKHVua25vd24ubGVuZ3RoID4gMCkge1xuICAgICAgd2FybmluZyhgVW5yZWNvZ25pemVkIHJlc291cmNlIGlkZW50aWZpZXJzIGluIG1hcHBpbmcgZmlsZTogJHt1bmtub3duLmpvaW4oJywgJyl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNlZCBvbiB0aGUgcHJvdmlkZWQgcmVzb3VyY2UgbWFwcGluZywgcHJlcGFyZSBDRk4gc3RydWN0dXJlcyBmb3IgaW1wb3J0ICh0ZW1wbGF0ZSxcbiAgICogUmVzb3VyY2VzVG9JbXBvcnQgc3RydWN0dXJlKSBhbmQgcGVyZm9ybSB0aGUgaW1wb3J0IG9wZXJhdGlvbiAoQ2xvdWRGb3JtYXRpb24gZGVwbG95bWVudClcbiAgICpcbiAgICogQHBhcmFtIGltcG9ydE1hcCBNYXBwaW5nIGZyb20gQ0RLIGNvbnN0cnVjdCB0cmVlIHBhdGggdG8gcGh5c2ljYWwgcmVzb3VyY2UgaW1wb3J0IGlkZW50aWZpZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyB0byBDbG91ZEZvcm1hdGlvbiBkZXBsb3kgb3BlcmF0aW9uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW1wb3J0UmVzb3VyY2VzKGltcG9ydE1hcDogSW1wb3J0TWFwLCBvcHRpb25zOiBEZXBsb3lTdGFja09wdGlvbnMpIHtcbiAgICBjb25zdCByZXNvdXJjZXNUb0ltcG9ydDogUmVzb3VyY2VzVG9JbXBvcnQgPSBhd2FpdCB0aGlzLm1ha2VSZXNvdXJjZXNUb0ltcG9ydChpbXBvcnRNYXApO1xuICAgIGNvbnN0IHVwZGF0ZWRUZW1wbGF0ZSA9IGF3YWl0IHRoaXMuY3VycmVudFRlbXBsYXRlV2l0aEFkZGl0aW9ucyhpbXBvcnRNYXAuaW1wb3J0UmVzb3VyY2VzKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNmbi5kZXBsb3lTdGFjayh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIG92ZXJyaWRlVGVtcGxhdGU6IHVwZGF0ZWRUZW1wbGF0ZSxcbiAgICAgICAgcmVzb3VyY2VzVG9JbXBvcnQsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3VsdC5ub09wXG4gICAgICAgID8gJyDinIUgICVzIChubyBjaGFuZ2VzKSdcbiAgICAgICAgOiAnIOKchSAgJXMnO1xuXG4gICAgICBzdWNjZXNzKCdcXG4nICsgbWVzc2FnZSwgb3B0aW9ucy5zdGFjay5kaXNwbGF5TmFtZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoJ1xcbiDinYwgICVzIGZhaWxlZDogJXMnLCBjaGFsay5ib2xkKG9wdGlvbnMuc3RhY2suZGlzcGxheU5hbWUpLCBlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBkaWZmIGJldHdlZW4gdGhlIGN1cnJlbnRseSBydW5uaW5nIGFuZCB0aGUgbmV3IHRlbXBsYXRlLCBlbnN1cmUgdGhhdCBpdCBpcyB2YWxpZFxuICAgKiBmb3IgaW1wb3J0aW5nIGFuZCByZXR1cm4gYSBsaXN0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBiZWluZyBhZGRlZCBpbiB0aGUgbmV3IHZlcnNpb25cbiAgICpcbiAgICogQHJldHVybiBtYXBwaW5nIGxvZ2ljYWxSZXNvdXJjZUlkIC0+IHJlc291cmNlRGlmZmVyZW5jZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpc2NvdmVySW1wb3J0YWJsZVJlc291cmNlcyhhbGxvd05vbkFkZGl0aW9ucyA9IGZhbHNlKTogUHJvbWlzZTxEaXNjb3ZlckltcG9ydGFibGVSZXNvdXJjZXNSZXN1bHQ+IHtcbiAgICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSBhd2FpdCB0aGlzLmN1cnJlbnRUZW1wbGF0ZSgpO1xuXG4gICAgY29uc3QgZGlmZiA9IGNmbkRpZmYuZGlmZlRlbXBsYXRlKGN1cnJlbnRUZW1wbGF0ZSwgdGhpcy5zdGFjay50ZW1wbGF0ZSk7XG5cbiAgICAvLyBJZ25vcmUgY2hhbmdlcyB0byBDREtNZXRhZGF0YVxuICAgIGNvbnN0IHJlc291cmNlQ2hhbmdlcyA9IE9iamVjdC5lbnRyaWVzKGRpZmYucmVzb3VyY2VzLmNoYW5nZXMpXG4gICAgICAuZmlsdGVyKChbbG9naWNhbElkLCBfXSkgPT4gbG9naWNhbElkICE9PSAnQ0RLTWV0YWRhdGEnKTtcblxuICAgIC8vIFNwbGl0IHRoZSBjaGFuZ2VzIGludG8gYWRkaXRpb25zIGFuZCBub24tYWRkaXRpb25zLiBJbXBvcnRzIG9ubHkgbWFrZSBzZW5zZVxuICAgIC8vIGZvciBuZXdseS1hZGRlZCByZXNvdXJjZXMuXG4gICAgY29uc3Qgbm9uQWRkaXRpb25zID0gcmVzb3VyY2VDaGFuZ2VzLmZpbHRlcigoW18sIGRpZl0pID0+ICFkaWYuaXNBZGRpdGlvbik7XG4gICAgY29uc3QgYWRkaXRpb25zID0gcmVzb3VyY2VDaGFuZ2VzLmZpbHRlcigoW18sIGRpZl0pID0+IGRpZi5pc0FkZGl0aW9uKTtcblxuICAgIGlmIChub25BZGRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZlbmRpbmdSZXNvdXJjZXMgPSBub25BZGRpdGlvbnMubWFwKChbbG9nSWQsIF9dKSA9PiB0aGlzLmRlc2NyaWJlUmVzb3VyY2UobG9nSWQpKTtcblxuICAgICAgaWYgKGFsbG93Tm9uQWRkaXRpb25zKSB7XG4gICAgICAgIHdhcm5pbmcoYElnbm9yaW5nIHVwZGF0ZWQvZGVsZXRlZCByZXNvdXJjZXMgKC0tZm9yY2UpOiAke29mZmVuZGluZ1Jlc291cmNlcy5qb2luKCcsICcpfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNvdXJjZSB1cGRhdGVzIG9yIGRlbGV0ZXMgYXJlIGFsbG93ZWQgb24gaW1wb3J0IG9wZXJhdGlvbi4gTWFrZSBzdXJlIHRvIHJlc29sdmUgcGVuZGluZyBjaGFuZ2VzICcgK1xuICAgICAgICAgIGB0byBleGlzdGluZyByZXNvdXJjZXMsIGJlZm9yZSBhdHRlbXB0aW5nIGFuIGltcG9ydC4gVXBkYXRlZC9kZWxldGVkIHJlc291cmNlczogJHtvZmZlbmRpbmdSZXNvdXJjZXMuam9pbignLCAnKX0gKC0tZm9yY2UgdG8gb3ZlcnJpZGUpYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzb3VyY2VzIGluIHRoZSBuZXcgdGVtcGxhdGUsIHRoYXQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBjdXJyZW50IHRlbXBsYXRlLCBhcmUgYSBwb3RlbnRpYWwgaW1wb3J0IGNhbmRpZGF0ZXNcbiAgICByZXR1cm4ge1xuICAgICAgYWRkaXRpb25zOiBhZGRpdGlvbnMubWFwKChbbG9naWNhbElkLCByZXNvdXJjZURpZmZdKSA9PiAoe1xuICAgICAgICBsb2dpY2FsSWQsXG4gICAgICAgIHJlc291cmNlRGlmZixcbiAgICAgICAgcmVzb3VyY2VEZWZpbml0aW9uOiBhZGREZWZhdWx0RGVsZXRpb25Qb2xpY3kodGhpcy5zdGFjay50ZW1wbGF0ZT8uUmVzb3VyY2VzPy5bbG9naWNhbElkXSA/PyB7fSksXG4gICAgICB9KSksXG4gICAgICBoYXNOb25BZGRpdGlvbnM6IG5vbkFkZGl0aW9ucy5sZW5ndGggPiAwLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnRseSBkZXBsb3llZCB0ZW1wbGF0ZSBvZiB0aGUgZ2l2ZW4gc3RhY2sgKFNJTkdMRVRPTilcbiAgICpcbiAgICogQHJldHVybnMgQ3VycmVudGx5IGRlcGxveWVkIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGN1cnJlbnRUZW1wbGF0ZSgpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghdGhpcy5fY3VycmVudFRlbXBsYXRlKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VGVtcGxhdGUgPSBhd2FpdCB0aGlzLmNmbi5yZWFkQ3VycmVudFRlbXBsYXRlKHRoaXMuc3RhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCB0ZW1wbGF0ZSwgd2l0aCB0aGUgZ2l2ZW4gcmVzb3VyY2VzIGFkZGVkIHRvIGl0XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGN1cnJlbnRUZW1wbGF0ZVdpdGhBZGRpdGlvbnMoYWRkaXRpb25zOiBJbXBvcnRhYmxlUmVzb3VyY2VbXSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBhd2FpdCB0aGlzLmN1cnJlbnRUZW1wbGF0ZSgpO1xuICAgIGlmICghdGVtcGxhdGUuUmVzb3VyY2VzKSB7XG4gICAgICB0ZW1wbGF0ZS5SZXNvdXJjZXMgPSB7fTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGFkZCBvZiBhZGRpdGlvbnMpIHtcbiAgICAgIHRlbXBsYXRlLlJlc291cmNlc1thZGQubG9naWNhbElkXSA9IGFkZC5yZXNvdXJjZURlZmluaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW1wb3J0IGlkZW50aWZpZXJzIGZvciBhbGwgcmVzb3VyY2UgdHlwZXMgdXNlZCBpbiB0aGUgZ2l2ZW5cbiAgICogdGVtcGxhdGUgdGhhdCBkbyBzdXBwb3J0IHRoZSBpbXBvcnQgb3BlcmF0aW9uIChTSU5HTEVUT04pXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbWFwcGluZyBmcm9tIGEgcmVzb3VyY2UgdHlwZSB0byBhIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCB0b2dldGhlciBpZGVudGlmeSB0aGUgcmVzb3VyY2UgZm9yIGltcG9ydFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZXNvdXJjZUlkZW50aWZpZXJzKCk6IFByb21pc2U8UmVzb3VyY2VJZGVudGlmaWVycz4ge1xuICAgIGNvbnN0IHJldDogUmVzb3VyY2VJZGVudGlmaWVycyA9IHt9O1xuICAgIGNvbnN0IHJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyA9IGF3YWl0IHRoaXMuY2ZuLnJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyh0aGlzLnN0YWNrLCB0aGlzLm9wdGlvbnMudG9vbGtpdFN0YWNrTmFtZSk7XG4gICAgZm9yIChjb25zdCBzdW1tYXJ5IG9mIHJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcykge1xuICAgICAgaWYgKCdSZXNvdXJjZVR5cGUnIGluIHN1bW1hcnkgJiYgc3VtbWFyeS5SZXNvdXJjZVR5cGUgJiYgJ1Jlc291cmNlSWRlbnRpZmllcnMnIGluIHN1bW1hcnkgJiYgc3VtbWFyeS5SZXNvdXJjZUlkZW50aWZpZXJzKSB7XG4gICAgICAgIHJldFtzdW1tYXJ5LlJlc291cmNlVHlwZV0gPSAoc3VtbWFyeS5SZXNvdXJjZUlkZW50aWZpZXJzID8/IFtdKT8ubWFwKHggPT4geC5zcGxpdCgnLCcpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc2sgZm9yIHRoZSBpbXBvcnRhYmxlIGlkZW50aWZpZXIgZm9yIHRoZSBnaXZlbiByZXNvdXJjZVxuICAgKlxuICAgKiBUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBpZGVudGlmaWVyIHVuZGVyIHdoaWNoIGEgcmVzb3VyY2UgY2FuIGJlIGltcG9ydGVkLiBUaGUgYGltcG9ydGBcbiAgICogb3BlcmF0aW9uIG5lZWRzIGV4YWN0bHkgb25lIG9mIHRoZW0uXG4gICAqXG4gICAqIC0gSWYgd2UgY2FuIGdldCBvbmUgZnJvbSB0aGUgdGVtcGxhdGUsIHdlIHdpbGwgdXNlIG9uZS5cbiAgICogLSBPdGhlcndpc2UsIHdlIHdpbGwgYXNrIHRoZSB1c2VyIGZvciBvbmUgb2YgdGhlbS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgYXNrRm9yUmVzb3VyY2VJZGVudGlmaWVyKFxuICAgIHJlc291cmNlSWRlbnRpZmllcnM6IFJlc291cmNlSWRlbnRpZmllcnMsXG4gICAgY2hnOiBJbXBvcnRhYmxlUmVzb3VyY2UsXG4gICk6IFByb21pc2U8UmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IHRoaXMuZGVzY3JpYmVSZXNvdXJjZShjaGcubG9naWNhbElkKTtcblxuICAgIC8vIFNraXAgcmVzb3VyY2VzIHRoYXQgZG8gbm90IHN1cHBvcnQgaW1wb3J0aW5nXG4gICAgY29uc3QgcmVzb3VyY2VUeXBlID0gY2hnLnJlc291cmNlRGlmZi5uZXdSZXNvdXJjZVR5cGU7XG4gICAgaWYgKHJlc291cmNlVHlwZSA9PT0gdW5kZWZpbmVkIHx8ICEocmVzb3VyY2VUeXBlIGluIHJlc291cmNlSWRlbnRpZmllcnMpKSB7XG4gICAgICB3YXJuaW5nKGAke3Jlc291cmNlTmFtZX06IHVuc3VwcG9ydGVkIHJlc291cmNlIHR5cGUgJHtyZXNvdXJjZVR5cGV9LCBza2lwcGluZyBpbXBvcnQuYCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGlkUHJvcFNldHMgPSByZXNvdXJjZUlkZW50aWZpZXJzW3Jlc291cmNlVHlwZV07XG5cbiAgICAvLyBSZXRhaW4gb25seSBsaXRlcmFsIHN0cmluZ3M6IHN0cmlwIHBvdGVudGlhbCBDRk4gaW50cmluc2ljc1xuICAgIGNvbnN0IHJlc291cmNlUHJvcHMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY2hnLnJlc291cmNlRGVmaW5pdGlvbi5Qcm9wZXJ0aWVzID8/IHt9KVxuICAgICAgLmZpbHRlcigoW18sIHZdKSA9PiB0eXBlb2YgdiA9PT0gJ3N0cmluZycpKSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG4gICAgLy8gRmluZCBwcm9wZXJ0eSBzZXRzIHRoYXQgYXJlIGZ1bGx5IHNhdGlzZmllZCBpbiB0aGUgdGVtcGxhdGUsIGFzayB0aGUgdXNlciB0byBjb25maXJtIHRoZW1cbiAgICBjb25zdCBzYXRpc2ZpZWRQcm9wU2V0cyA9IGlkUHJvcFNldHMuZmlsdGVyKHBzID0+IHBzLmV2ZXJ5KHAgPT4gcmVzb3VyY2VQcm9wc1twXSkpO1xuICAgIGZvciAoY29uc3Qgc2F0aXNmaWVkUHJvcFNldCBvZiBzYXRpc2ZpZWRQcm9wU2V0cykge1xuICAgICAgY29uc3QgY2FuZGlkYXRlUHJvcHMgPSBPYmplY3QuZnJvbUVudHJpZXMoc2F0aXNmaWVkUHJvcFNldC5tYXAocCA9PiBbcCwgcmVzb3VyY2VQcm9wc1twXV0pKTtcbiAgICAgIGNvbnN0IGRpc3BsYXlDYW5kaWRhdGVQcm9wcyA9IGZtdGRpY3QoY2FuZGlkYXRlUHJvcHMpO1xuXG4gICAgICBpZiAoYXdhaXQgcHJvbXB0bHkuY29uZmlybShcbiAgICAgICAgYCR7Y2hhbGsuYmx1ZShyZXNvdXJjZU5hbWUpfSAoJHtyZXNvdXJjZVR5cGV9KTogaW1wb3J0IHdpdGggJHtjaGFsay55ZWxsb3coZGlzcGxheUNhbmRpZGF0ZVByb3BzKX0gKHllcy9ubykgW2RlZmF1bHQ6IHllc10/IGAsXG4gICAgICAgIHsgZGVmYXVsdDogJ3llcycgfSxcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZVByb3BzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGdvdCBoZXJlIGFuZCB0aGUgdXNlciByZWplY3RlZCBhbnkgYXZhaWxhYmxlIGlkZW50aWZpZXJzLCB0aGVuIGFwcGFyZW50bHkgdGhleSBkb24ndCB3YW50IHRoZSByZXNvdXJjZSBhdCBhbGxcbiAgICBpZiAoc2F0aXNmaWVkUHJvcFNldHMubGVuZ3RoID4gMCkge1xuICAgICAgcHJpbnQoY2hhbGsuZ3JleShgU2tpcHBpbmcgaW1wb3J0IG9mICR7cmVzb3VyY2VOYW1lfWApKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gV2UgY2Fubm90IGF1dG8taW1wb3J0IHRoaXMsIGFzayB0aGUgdXNlciBmb3Igb25lIG9mIHRoZSBwcm9wc1xuICAgIC8vIFRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVzZSBjYXNlcyBpcyB3aGF0IHdlIHByaW50OiBmb3IgbXVsdGlwbGUgcHJvcGVydGllcywgd2UgcHJpbnQgYSBwcmVhbWJsZVxuICAgIGNvbnN0IHByZWZpeCA9IGAke2NoYWxrLmJsdWUocmVzb3VyY2VOYW1lKX0gKCR7cmVzb3VyY2VUeXBlfSlgO1xuICAgIGxldCBwcmVhbWJsZTtcbiAgICBsZXQgcHJvbXB0UGF0dGVybjtcbiAgICBpZiAoaWRQcm9wU2V0cy5sZW5ndGggPiAxKSB7XG4gICAgICBwcmVhbWJsZSA9IGAke3ByZWZpeH06IGVudGVyIG9uZSBvZiAke2lkUHJvcFNldHMubWFwKHggPT4gY2hhbGsuYmx1ZSh4LmpvaW4oJysnKSkpLmpvaW4oJywgJyl9IHRvIGltcG9ydCAoYWxsIGVtcHR5IHRvIHNraXApYDtcbiAgICAgIHByb21wdFBhdHRlcm4gPSBgJHtwcmVmaXh9OiBlbnRlciAlYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbXB0UGF0dGVybiA9IGAke3ByZWZpeH06IGVudGVyICVgO1xuICAgIH1cblxuICAgIC8vIERvIHRoZSBpbnB1dCBsb29wIGhlcmVcbiAgICBpZiAocHJlYW1ibGUpIHtcbiAgICAgIHByaW50KHByZWFtYmxlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpZFByb3BzIG9mIGlkUHJvcFNldHMpIHtcbiAgICAgIGNvbnN0IGlucHV0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGlkUHJvcCBvZiBpZFByb3BzKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSB2YWx1ZSBmcm9tIHRoZSB0ZW1wbGF0ZSwgdXNlIGl0IGFzIGRlZmF1bHQuIFRoaXMgd2lsbCBvbmx5IGJlIGEgcGFydGlhbFxuICAgICAgICAvLyBpZGVudGlmaWVyIGlmIHByZXNlbnQsIG90aGVyd2lzZSB3ZSB3b3VsZCBoYXZlIGRvbmUgdGhlIGltcG9ydCBhbHJlYWR5IGFib3ZlLlxuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0eXBlb2YgcmVzb3VyY2VQcm9wc1tpZFByb3BdID8/ICcnO1xuXG4gICAgICAgIGNvbnN0IHByb21wdCA9IFtcbiAgICAgICAgICBwcm9tcHRQYXR0ZXJuLnJlcGxhY2UoLyUvLCBjaGFsay5ibHVlKGlkUHJvcCkpLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgPyBgWyR7ZGVmYXVsdFZhbHVlfV1gXG4gICAgICAgICAgICA6ICcoZW1wdHkgdG8gc2tpcCknLFxuICAgICAgICBdLmpvaW4oJyAnKSArICc6JztcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwcm9tcHRseS5wcm9tcHQocHJvbXB0LFxuICAgICAgICAgIHsgZGVmYXVsdDogZGVmYXVsdFZhbHVlLCB0cmltOiB0cnVlIH0sXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRbaWRQcm9wXSA9IHJlc3BvbnNlO1xuICAgICAgICAvLyBBbHNvIHN0aWNrIHRoaXMgcHJvcGVydHkgaW50byAncmVzb3VyY2VQcm9wcycsIHNvIHRoYXQgaXQgbWF5IGJlIHJldXNlZCBieSBhIHN1YnNlcXVlbnQgcXVlc3Rpb25cbiAgICAgICAgLy8gKGZvciBhIGRpZmZlcmVudCBjb21wb3VuZCBpZGVudGlmaWVyIHRoYXQgaW52b2x2ZXMgdGhlIHNhbWUgcHJvcGVydHkpLiBKdXN0IGEgc21hbGwgVVggZW5oYW5jZW1lbnQuXG4gICAgICAgIHJlc291cmNlUHJvcHNbaWRQcm9wXSA9IHJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgdXNlciBnYXZlIGlucHV0cyBmb3IgYWxsIHZhbHVlcywgd2UgYXJlIGNvbXBsZXRlXG4gICAgICBpZiAoT2JqZWN0LmtleXMoaW5wdXQpLmxlbmd0aCA9PT0gaWRQcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHByaW50KGNoYWxrLmdyZXkoYFNraXBwaW5nIGltcG9ydCBvZiAke3Jlc291cmNlTmFtZX1gKSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBpbnRlcm5hbCBcInJlc291cmNlIG1hcHBpbmdcIiBzdHJ1Y3R1cmUgdG8gQ2xvdWRGb3JtYXRpb24gYWNjZXB0ZWQgXCJSZXNvdXJjZXNUb0ltcG9ydFwiIHN0cnVjdHVyZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBtYWtlUmVzb3VyY2VzVG9JbXBvcnQocmVzb3VyY2VNYXA6IEltcG9ydE1hcCk6IFByb21pc2U8UmVzb3VyY2VzVG9JbXBvcnQ+IHtcbiAgICByZXR1cm4gcmVzb3VyY2VNYXAuaW1wb3J0UmVzb3VyY2VzLm1hcChyZXMgPT4gKHtcbiAgICAgIExvZ2ljYWxSZXNvdXJjZUlkOiByZXMubG9naWNhbElkLFxuICAgICAgUmVzb3VyY2VUeXBlOiByZXMucmVzb3VyY2VEaWZmLm5ld1Jlc291cmNlVHlwZSEsXG4gICAgICBSZXNvdXJjZUlkZW50aWZpZXI6IHJlc291cmNlTWFwLnJlc291cmNlTWFwW3Jlcy5sb2dpY2FsSWRdLFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IENsb3VkRm9ybWF0aW9uIGxvZ2ljYWwgcmVzb3VyY2UgSUQgdG8gQ0RLIGNvbnN0cnVjdCB0cmVlIHBhdGhcbiAgICpcbiAgICogQHBhcmFtIGxvZ2ljYWxJZCBDbG91ZEZvcm1hdGlvbiBsb2dpY2FsIElEIG9mIHRoZSByZXNvdXJjZSAodGhlIGtleSBpbiB0aGUgdGVtcGxhdGUncyBSZXNvdXJjZXMgc2VjdGlvbilcbiAgICogQHJldHVybnMgRm9yd2FyZC1zbGFzaCBzZXBhcmF0ZWQgcGF0aCBvZiB0aGUgcmVzb3VyY2UgaW4gQ0RLIGNvbnN0cnVjdCB0cmVlLCBlLmcuIE15U3RhY2svTXlCdWNrZXQvUmVzb3VyY2VcbiAgICovXG4gIHByaXZhdGUgZGVzY3JpYmVSZXNvdXJjZShsb2dpY2FsSWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2sudGVtcGxhdGU/LlJlc291cmNlcz8uW2xvZ2ljYWxJZF0/Lk1ldGFkYXRhPy5bJ2F3czpjZGs6cGF0aCddID8/IGxvZ2ljYWxJZDtcbiAgfVxufVxuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IGEgcmVzb3VyY2UgaW4gdGhlIHRlbXBsYXRlIHRoYXQgaXMgaW1wb3J0YWJsZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltcG9ydGFibGVSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBUaGUgbG9naWNhbCBJRCBvZiB0aGUgcmVzb3VyY2VcbiAgICovXG4gIHJlYWRvbmx5IGxvZ2ljYWxJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVzb3VyY2UgZGVmaW5pdGlvbiBpbiB0aGUgbmV3IHRlbXBsYXRlXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZURlZmluaXRpb246IGFueTtcblxuICAvKipcbiAgICogVGhlIGRpZmYgYXMgcmVwb3J0ZWQgYnkgYGNsb3VkZm9ybWF0aW9uLWRpZmZgLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VEaWZmOiBSZXNvdXJjZURpZmZlcmVuY2U7XG59XG5cbi8qKlxuICogVGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBleGVjdXRlIGFuIGltcG9ydCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRNYXAge1xuICAvKipcbiAgICogTWFwcGluZyBsb2dpY2FsIElEcyB0byBwaHlzaWNhbCBuYW1lc1xuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VNYXA6IFJlc291cmNlTWFwO1xuXG4gIC8qKlxuICAgKiBUaGUgc2VsZWN0aW9uIG9mIHJlc291cmNlcyB3ZSBhcmUgYWN0dWFsbHkgaW1wb3J0aW5nXG4gICAqXG4gICAqIEZvciBlYWNoIG9mIHRoZSByZXNvdXJjZXMgaW4gdGhpcyBsaXN0LCB0aGVyZSBpcyBhIGNvcnJlc3BvbmRpbmcgZW50cnkgaW5cbiAgICogdGhlIGByZXNvdXJjZU1hcGAgbWFwLlxuICAgKi9cbiAgcmVhZG9ubHkgaW1wb3J0UmVzb3VyY2VzOiBJbXBvcnRhYmxlUmVzb3VyY2VbXTtcbn1cblxuZnVuY3Rpb24gZm10ZGljdDxBPih4czogUmVjb3JkPHN0cmluZywgQT4pIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHhzKS5tYXAoKFtrLCB2XSkgPT4gYCR7a309JHt2fWApLmpvaW4oJywgJyk7XG59XG5cbi8qKlxuICogQWRkIGEgZGVmYXVsdCBgRGVsZXRpb25Qb2xpY3lgIHBvbGljeS5cbiAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHNldCB0byAnUmV0YWluJywgdG8gbG93ZXIgcmlzayBvZiB1bmludGVudGlvbmFsbHlcbiAqIGRlbGV0aW5nIHN0YXRlZnVsIHJlc291cmNlcyBpbiB0aGUgcHJvY2VzcyBvZiBpbXBvcnRpbmcgdG8gQ0RLLlxuICovXG5mdW5jdGlvbiBhZGREZWZhdWx0RGVsZXRpb25Qb2xpY3kocmVzb3VyY2U6IGFueSk6IGFueSB7XG4gIGlmIChyZXNvdXJjZS5EZWxldGlvblBvbGljeSkgeyByZXR1cm4gcmVzb3VyY2U7IH1cblxuICByZXR1cm4ge1xuICAgIC4uLnJlc291cmNlLFxuICAgIERlbGV0aW9uUG9saWN5OiAnUmV0YWluJyxcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEaXNjb3ZlckltcG9ydGFibGVSZXNvdXJjZXNSZXN1bHQge1xuICByZWFkb25seSBhZGRpdGlvbnM6IEltcG9ydGFibGVSZXNvdXJjZVtdO1xuICByZWFkb25seSBoYXNOb25BZGRpdGlvbnM6IGJvb2xlYW47XG59XG4iXX0=