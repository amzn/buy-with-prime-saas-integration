"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginHost = void 0;
const util_1 = require("util");
const chalk = require("chalk");
const _env_1 = require("./_env");
const context_provider_plugin_1 = require("./context-provider-plugin");
/**
 * A utility to manage plug-ins.
 *
 */
class PluginHost {
    constructor() {
        /**
         * Access the currently registered CredentialProviderSources. New sources can
         * be registered using the +registerCredentialProviderSource+ method.
         */
        this.credentialProviderSources = new Array();
        this.contextProviderPlugins = {};
        if (PluginHost.instance && PluginHost.instance !== this) {
            throw new Error('New instances of PluginHost must not be built. Use PluginHost.instance instead!');
        }
    }
    /**
     * Loads a plug-in into this PluginHost.
     *
     * @param moduleSpec the specification (path or name) of the plug-in module to be loaded.
     */
    load(moduleSpec) {
        try {
            /* eslint-disable @typescript-eslint/no-require-imports */
            const plugin = require(moduleSpec);
            /* eslint-enable */
            if (!isPlugin(plugin)) {
                (0, _env_1.error)(`Module ${chalk.green(moduleSpec)} is not a valid plug-in, or has an unsupported version.`);
                throw new Error(`Module ${moduleSpec} does not define a valid plug-in.`);
            }
            if (plugin.init) {
                plugin.init(PluginHost.instance);
            }
        }
        catch (e) {
            (0, _env_1.error)(`Unable to load ${chalk.green(moduleSpec)}: ${e.stack}`);
            throw new Error(`Unable to load plug-in: ${moduleSpec}`);
        }
        function isPlugin(x) {
            return x != null && x.version === '1';
        }
    }
    /**
     * Allows plug-ins to register new CredentialProviderSources.
     *
     * @param source a new CredentialProviderSource to register.
     */
    registerCredentialProviderSource(source) {
        // Forward to the right credentials-related plugin host
        this.credentialProviderSources.push(source);
    }
    /**
     * (EXPERIMENTAL) Allow plugins to register context providers
     *
     * Context providers are objects with the following method:
     *
     * ```ts
     *   getValue(args: {[key: string]: any}): Promise<any>;
     * ```
     *
     * Currently, they cannot reuse the CDK's authentication mechanisms, so they
     * must be prepared to either not make AWS calls or use their own source of
     * AWS credentials.
     *
     * This feature is experimental, and only intended to be used internally at Amazon
     * as a trial.
     *
     * After registering with 'my-plugin-name', the provider must be addressed as follows:
     *
     * ```ts
     * const value = ContextProvider.getValue(this, {
     *   providerName: 'plugin',
     *   props: {
     *     pluginName: 'my-plugin-name',
     *     myParameter1: 'xyz',
     *   },
     *   includeEnvironment: true | false,
     *   dummyValue: 'what-to-return-on-the-first-pass',
     * })
     * ```
     *
     * @experimental
     */
    registerContextProviderAlpha(pluginProviderName, provider) {
        if (!(0, context_provider_plugin_1.isContextProviderPlugin)(provider)) {
            throw new Error(`Object you gave me does not look like a ContextProviderPlugin: ${(0, util_1.inspect)(provider)}`);
        }
        this.contextProviderPlugins[pluginProviderName] = provider;
    }
}
exports.PluginHost = PluginHost;
PluginHost.instance = new PluginHost();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGx1Z2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFFL0IsaUNBQStCO0FBQy9CLHVFQUEyRjtBQWtDM0Y7OztHQUdHO0FBQ0gsTUFBYSxVQUFVO0lBV3JCO1FBUkE7OztXQUdHO1FBQ2EsOEJBQXlCLEdBQUcsSUFBSSxLQUFLLEVBQTRCLENBQUM7UUFFbEUsMkJBQXNCLEdBQTBDLEVBQUUsQ0FBQztRQUdqRixJQUFJLFVBQVUsQ0FBQyxRQUFRLElBQUksVUFBVSxDQUFDLFFBQVEsS0FBSyxJQUFJLEVBQUU7WUFDdkQsTUFBTSxJQUFJLEtBQUssQ0FBQyxpRkFBaUYsQ0FBQyxDQUFDO1NBQ3BHO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxJQUFJLENBQUMsVUFBa0I7UUFDNUIsSUFBSTtZQUNGLDBEQUEwRDtZQUMxRCxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbkMsbUJBQW1CO1lBQ25CLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQ3JCLElBQUEsWUFBSyxFQUFDLFVBQVUsS0FBSyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMseURBQXlELENBQUMsQ0FBQztnQkFDbEcsTUFBTSxJQUFJLEtBQUssQ0FBQyxVQUFVLFVBQVUsbUNBQW1DLENBQUMsQ0FBQzthQUMxRTtZQUNELElBQUksTUFBTSxDQUFDLElBQUksRUFBRTtnQkFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUFFO1NBQ3ZEO1FBQUMsT0FBTyxDQUFNLEVBQUU7WUFDZixJQUFBLFlBQUssRUFBQyxrQkFBa0IsS0FBSyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUMvRCxNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixVQUFVLEVBQUUsQ0FBQyxDQUFDO1NBQzFEO1FBRUQsU0FBUyxRQUFRLENBQUMsQ0FBTTtZQUN0QixPQUFPLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLE9BQU8sS0FBSyxHQUFHLENBQUM7UUFDeEMsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksZ0NBQWdDLENBQUMsTUFBZ0M7UUFDdEUsdURBQXVEO1FBQ3ZELElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BK0JHO0lBQ0ksNEJBQTRCLENBQUMsa0JBQTBCLEVBQUUsUUFBK0I7UUFDN0YsSUFBSSxDQUFDLElBQUEsaURBQXVCLEVBQUMsUUFBUSxDQUFDLEVBQUU7WUFDdEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrRUFBa0UsSUFBQSxjQUFPLEVBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3hHO1FBQ0QsSUFBSSxDQUFDLHNCQUFzQixDQUFDLGtCQUFrQixDQUFDLEdBQUcsUUFBUSxDQUFDO0lBQzdELENBQUM7O0FBekZILGdDQTBGQztBQXpGZSxtQkFBUSxHQUFHLElBQUksVUFBVSxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbnNwZWN0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5cbmltcG9ydCB7IGVycm9yIH0gZnJvbSAnLi9fZW52JztcbmltcG9ydCB7IENvbnRleHRQcm92aWRlclBsdWdpbiwgaXNDb250ZXh0UHJvdmlkZXJQbHVnaW4gfSBmcm9tICcuL2NvbnRleHQtcHJvdmlkZXItcGx1Z2luJztcbmltcG9ydCB7IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZSB9IGZyb20gJy4vY3JlZGVudGlhbC1wcm92aWRlci1zb3VyY2UnO1xuXG4vKipcbiAqIFRoZSBiYXNpYyBjb250cmFjdCBmb3IgcGx1Zy1pbnMgdG8gYWRoZXJlIHRvOjpcbiAqXG4gKiAgIGltcG9ydCB7IFBsdWdpbiwgUGx1Z2luSG9zdCB9IGZyb20gJ2F3cy1jZGsnO1xuICogICBpbXBvcnQgeyBDdXN0b21DcmVkZW50aWFsUHJvdmlkZXJTb3VyY2UgfSBmcm9tICcuL2N1c3RvbS1jcmVkZW50aWFsLXByb3ZpZGVyLXNvdXJjZSc7XG4gKlxuICogICBleHBvcnQgZGVmYXVsdCBjbGFzcyBGb29DREtQbHVnSW4gaW1wbGVtZW50cyBQbHVnaW5Ib3N0IHtcbiAqICAgICBwdWJsaWMgcmVhZG9ubHkgdmVyc2lvbiA9ICcxJztcbiAqXG4gKiAgICAgcHVibGljIGluaXQoaG9zdDogUGx1Z2luSG9zdCkge1xuICogICAgIGhvc3QucmVnaXN0ZXJDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2UobmV3IEN1c3RvbUNyZWRlbnRpYWxQcm92aWRlclNvdXJjZSgpKTtcbiAqICAgICB9XG4gKiAgIH1cbiAqXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGx1Z2luIHtcbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBwbHVnLWluIGludGVyZmFjZSB1c2VkIGJ5IHRoZSBwbHVnLWluLiBUaGlzIHdpbGwgYmUgdXNlZCBieVxuICAgKiB0aGUgcGx1Zy1pbiBob3N0IHRvIGhhbmRsZSB2ZXJzaW9uIGNoYW5nZXMuXG4gICAqL1xuICB2ZXJzaW9uOiAnMSc7XG5cbiAgLyoqXG4gICAqIFdoZW4gZGVmaW5lZCwgdGhpcyBmdW5jdGlvbiBpcyBpbnZva2VkIHJpZ2h0IGFmdGVyIHRoZSBwbHVnLWluIGhhcyBiZWVuIGxvYWRlZCxcbiAgICogc28gdGhhdCB0aGUgcGx1Zy1pbiBpcyBhYmxlIHRvIGluaXRpYWxpemUgaXRzZWxmLiBJdCBtYXkgY2FsbCBtZXRob2RzIG9mIHRoZVxuICAgKiBgYFBsdWdpbkhvc3RgYCBpbnN0YW5jZSBpdCByZWNlaXZlcyB0byByZWdpc3RlciBuZXcgYGBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VgYFxuICAgKiBpbnN0YW5jZXMuXG4gICAqL1xuICBpbml0PzogKGhvc3Q6IFBsdWdpbkhvc3QpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogQSB1dGlsaXR5IHRvIG1hbmFnZSBwbHVnLWlucy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBQbHVnaW5Ib3N0IHtcbiAgcHVibGljIHN0YXRpYyBpbnN0YW5jZSA9IG5ldyBQbHVnaW5Ib3N0KCk7XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlcy4gTmV3IHNvdXJjZXMgY2FuXG4gICAqIGJlIHJlZ2lzdGVyZWQgdXNpbmcgdGhlICtyZWdpc3RlckNyZWRlbnRpYWxQcm92aWRlclNvdXJjZSsgbWV0aG9kLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNyZWRlbnRpYWxQcm92aWRlclNvdXJjZXMgPSBuZXcgQXJyYXk8Q3JlZGVudGlhbFByb3ZpZGVyU291cmNlPigpO1xuXG4gIHB1YmxpYyByZWFkb25seSBjb250ZXh0UHJvdmlkZXJQbHVnaW5zOiBSZWNvcmQ8c3RyaW5nLCBDb250ZXh0UHJvdmlkZXJQbHVnaW4+ID0ge307XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKFBsdWdpbkhvc3QuaW5zdGFuY2UgJiYgUGx1Z2luSG9zdC5pbnN0YW5jZSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXcgaW5zdGFuY2VzIG9mIFBsdWdpbkhvc3QgbXVzdCBub3QgYmUgYnVpbHQuIFVzZSBQbHVnaW5Ib3N0Lmluc3RhbmNlIGluc3RlYWQhJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIGEgcGx1Zy1pbiBpbnRvIHRoaXMgUGx1Z2luSG9zdC5cbiAgICpcbiAgICogQHBhcmFtIG1vZHVsZVNwZWMgdGhlIHNwZWNpZmljYXRpb24gKHBhdGggb3IgbmFtZSkgb2YgdGhlIHBsdWctaW4gbW9kdWxlIHRvIGJlIGxvYWRlZC5cbiAgICovXG4gIHB1YmxpYyBsb2FkKG1vZHVsZVNwZWM6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG4gICAgICBjb25zdCBwbHVnaW4gPSByZXF1aXJlKG1vZHVsZVNwZWMpO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgaWYgKCFpc1BsdWdpbihwbHVnaW4pKSB7XG4gICAgICAgIGVycm9yKGBNb2R1bGUgJHtjaGFsay5ncmVlbihtb2R1bGVTcGVjKX0gaXMgbm90IGEgdmFsaWQgcGx1Zy1pbiwgb3IgaGFzIGFuIHVuc3VwcG9ydGVkIHZlcnNpb24uYCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTW9kdWxlICR7bW9kdWxlU3BlY30gZG9lcyBub3QgZGVmaW5lIGEgdmFsaWQgcGx1Zy1pbi5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChwbHVnaW4uaW5pdCkgeyBwbHVnaW4uaW5pdChQbHVnaW5Ib3N0Lmluc3RhbmNlKTsgfVxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgZXJyb3IoYFVuYWJsZSB0byBsb2FkICR7Y2hhbGsuZ3JlZW4obW9kdWxlU3BlYyl9OiAke2Uuc3RhY2t9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkIHBsdWctaW46ICR7bW9kdWxlU3BlY31gKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BsdWdpbih4OiBhbnkpOiB4IGlzIFBsdWdpbiB7XG4gICAgICByZXR1cm4geCAhPSBudWxsICYmIHgudmVyc2lvbiA9PT0gJzEnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgcGx1Zy1pbnMgdG8gcmVnaXN0ZXIgbmV3IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSBzb3VyY2UgYSBuZXcgQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlIHRvIHJlZ2lzdGVyLlxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlKHNvdXJjZTogQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlKSB7XG4gICAgLy8gRm9yd2FyZCB0byB0aGUgcmlnaHQgY3JlZGVudGlhbHMtcmVsYXRlZCBwbHVnaW4gaG9zdFxuICAgIHRoaXMuY3JlZGVudGlhbFByb3ZpZGVyU291cmNlcy5wdXNoKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogKEVYUEVSSU1FTlRBTCkgQWxsb3cgcGx1Z2lucyB0byByZWdpc3RlciBjb250ZXh0IHByb3ZpZGVyc1xuICAgKlxuICAgKiBDb250ZXh0IHByb3ZpZGVycyBhcmUgb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgbWV0aG9kOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAgIGdldFZhbHVlKGFyZ3M6IHtba2V5OiBzdHJpbmddOiBhbnl9KTogUHJvbWlzZTxhbnk+O1xuICAgKiBgYGBcbiAgICpcbiAgICogQ3VycmVudGx5LCB0aGV5IGNhbm5vdCByZXVzZSB0aGUgQ0RLJ3MgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtcywgc28gdGhleVxuICAgKiBtdXN0IGJlIHByZXBhcmVkIHRvIGVpdGhlciBub3QgbWFrZSBBV1MgY2FsbHMgb3IgdXNlIHRoZWlyIG93biBzb3VyY2Ugb2ZcbiAgICogQVdTIGNyZWRlbnRpYWxzLlxuICAgKlxuICAgKiBUaGlzIGZlYXR1cmUgaXMgZXhwZXJpbWVudGFsLCBhbmQgb25seSBpbnRlbmRlZCB0byBiZSB1c2VkIGludGVybmFsbHkgYXQgQW1hem9uXG4gICAqIGFzIGEgdHJpYWwuXG4gICAqXG4gICAqIEFmdGVyIHJlZ2lzdGVyaW5nIHdpdGggJ215LXBsdWdpbi1uYW1lJywgdGhlIHByb3ZpZGVyIG11c3QgYmUgYWRkcmVzc2VkIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHZhbHVlID0gQ29udGV4dFByb3ZpZGVyLmdldFZhbHVlKHRoaXMsIHtcbiAgICogICBwcm92aWRlck5hbWU6ICdwbHVnaW4nLFxuICAgKiAgIHByb3BzOiB7XG4gICAqICAgICBwbHVnaW5OYW1lOiAnbXktcGx1Z2luLW5hbWUnLFxuICAgKiAgICAgbXlQYXJhbWV0ZXIxOiAneHl6JyxcbiAgICogICB9LFxuICAgKiAgIGluY2x1ZGVFbnZpcm9ubWVudDogdHJ1ZSB8IGZhbHNlLFxuICAgKiAgIGR1bW15VmFsdWU6ICd3aGF0LXRvLXJldHVybi1vbi10aGUtZmlyc3QtcGFzcycsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXJDb250ZXh0UHJvdmlkZXJBbHBoYShwbHVnaW5Qcm92aWRlck5hbWU6IHN0cmluZywgcHJvdmlkZXI6IENvbnRleHRQcm92aWRlclBsdWdpbikge1xuICAgIGlmICghaXNDb250ZXh0UHJvdmlkZXJQbHVnaW4ocHJvdmlkZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCB5b3UgZ2F2ZSBtZSBkb2VzIG5vdCBsb29rIGxpa2UgYSBDb250ZXh0UHJvdmlkZXJQbHVnaW46ICR7aW5zcGVjdChwcm92aWRlcil9YCk7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dFByb3ZpZGVyUGx1Z2luc1twbHVnaW5Qcm92aWRlck5hbWVdID0gcHJvdmlkZXI7XG4gIH1cbn1cbiJdfQ==