"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SdkProvider_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultCliUserAgent = exports.SdkProvider = void 0;
const os = require("os");
const path = require("path");
const cxapi = require("@aws-cdk/cx-api");
const AWS = require("aws-sdk");
const fs = require("fs-extra");
const _env_1 = require("./_env");
const awscli_compatible_1 = require("./awscli-compatible");
const cached_1 = require("./cached");
const credential_plugins_1 = require("./credential-plugins");
const sdk_1 = require("./sdk");
const directories_1 = require("../../util/directories");
const tracing_1 = require("../../util/tracing");
// Some configuration that can only be achieved by setting
// environment variables.
process.env.AWS_STS_REGIONAL_ENDPOINTS = 'regional';
process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = '1';
const CACHED_ACCOUNT = Symbol('cached_account');
const CACHED_DEFAULT_CREDENTIALS = Symbol('cached_default_credentials');
/**
 * Creates instances of the AWS SDK appropriate for a given account/region.
 *
 * Behavior is as follows:
 *
 * - First, a set of "base" credentials are established
 *   - If a target environment is given and the default ("current") SDK credentials are for
 *     that account, return those; otherwise
 *   - If a target environment is given, scan all credential provider plugins
 *     for credentials, and return those if found; otherwise
 *   - Return default ("current") SDK credentials, noting that they might be wrong.
 *
 * - Second, a role may optionally need to be assumed. Use the base credentials
 *   established in the previous process to assume that role.
 *   - If assuming the role fails and the base credentials are for the correct
 *     account, return those. This is a fallback for people who are trying to interact
 *     with a Default Synthesized stack and already have right credentials setup.
 *
 *     Typical cases we see in the wild:
 *     - Credential plugin setup that, although not recommended, works for them
 *     - Seeded terminal with `ReadOnly` credentials in order to do `cdk diff`--the `ReadOnly`
 *       role doesn't have `sts:AssumeRole` and will fail for no real good reason.
 */
let SdkProvider = SdkProvider_1 = class SdkProvider {
    /**
     * Create a new SdkProvider which gets its defaults in a way that behaves like the AWS CLI does
     *
     * The AWS SDK for JS behaves slightly differently from the AWS CLI in a number of ways; see the
     * class `AwsCliCompatible` for the details.
     */
    static async withAwsCliCompatibleDefaults(options = {}) {
        const sdkOptions = parseHttpOptions(options.httpOptions ?? {});
        const chain = await awscli_compatible_1.AwsCliCompatible.credentialChain({
            profile: options.profile,
            ec2instance: options.ec2creds,
            containerCreds: options.containerCreds,
            httpOptions: sdkOptions.httpOptions,
        });
        const region = await awscli_compatible_1.AwsCliCompatible.region({
            profile: options.profile,
            ec2instance: options.ec2creds,
        });
        return new SdkProvider_1(chain, region, sdkOptions);
    }
    constructor(defaultChain, 
    /**
     * Default region
     */
    defaultRegion, sdkOptions = {}) {
        this.defaultChain = defaultChain;
        this.defaultRegion = defaultRegion;
        this.sdkOptions = sdkOptions;
        this.plugins = new credential_plugins_1.CredentialPlugins();
    }
    /**
     * Return an SDK which can do operations in the given environment
     *
     * The `environment` parameter is resolved first (see `resolveEnvironment()`).
     */
    async forEnvironment(environment, mode, options) {
        const env = await this.resolveEnvironment(environment);
        const baseCreds = await this.obtainBaseCredentials(env.account, mode);
        // At this point, we need at least SOME credentials
        if (baseCreds.source === 'none') {
            throw new Error(fmtObtainCredentialsError(env.account, baseCreds));
        }
        // Simple case is if we don't need to "assumeRole" here. If so, we must now have credentials for the right
        // account.
        if (options?.assumeRoleArn === undefined) {
            if (baseCreds.source === 'incorrectDefault') {
                throw new Error(fmtObtainCredentialsError(env.account, baseCreds));
            }
            // Our current credentials must be valid and not expired. Confirm that before we get into doing
            // actual CloudFormation calls, which might take a long time to hang.
            const sdk = new sdk_1.SDK(baseCreds.credentials, env.region, this.sdkOptions);
            await sdk.validateCredentials();
            return { sdk, didAssumeRole: false };
        }
        // We will proceed to AssumeRole using whatever we've been given.
        const sdk = await this.withAssumedRole(baseCreds, options.assumeRoleArn, options.assumeRoleExternalId, env.region);
        // Exercise the AssumeRoleCredentialsProvider we've gotten at least once so
        // we can determine whether the AssumeRole call succeeds or not.
        try {
            await sdk.forceCredentialRetrieval();
            return { sdk, didAssumeRole: true };
        }
        catch (e) {
            if ((0, sdk_1.isUnrecoverableAwsError)(e)) {
                throw e;
            }
            // AssumeRole failed. Proceed and warn *if and only if* the baseCredentials were already for the right account
            // or returned from a plugin. This is to cover some current setups for people using plugins or preferring to
            // feed the CLI credentials which are sufficient by themselves. Prefer to assume the correct role if we can,
            // but if we can't then let's just try with available credentials anyway.
            if (baseCreds.source === 'correctDefault' || baseCreds.source === 'plugin') {
                (0, _env_1.debug)(e.message);
                (0, _env_1.warning)(`${fmtObtainedCredentials(baseCreds)} could not be used to assume '${options.assumeRoleArn}', but are for the right account. Proceeding anyway.`);
                return { sdk: new sdk_1.SDK(baseCreds.credentials, env.region, this.sdkOptions), didAssumeRole: false };
            }
            throw e;
        }
    }
    /**
     * Return the partition that base credentials are for
     *
     * Returns `undefined` if there are no base credentials.
     */
    async baseCredentialsPartition(environment, mode) {
        const env = await this.resolveEnvironment(environment);
        const baseCreds = await this.obtainBaseCredentials(env.account, mode);
        if (baseCreds.source === 'none') {
            return undefined;
        }
        return (await new sdk_1.SDK(baseCreds.credentials, env.region, this.sdkOptions).currentAccount()).partition;
    }
    /**
     * Resolve the environment for a stack
     *
     * Replaces the magic values `UNKNOWN_REGION` and `UNKNOWN_ACCOUNT`
     * with the defaults for the current SDK configuration (`~/.aws/config` or
     * otherwise).
     *
     * It is an error if `UNKNOWN_ACCOUNT` is used but the user hasn't configured
     * any SDK credentials.
     */
    async resolveEnvironment(env) {
        const region = env.region !== cxapi.UNKNOWN_REGION ? env.region : this.defaultRegion;
        const account = env.account !== cxapi.UNKNOWN_ACCOUNT ? env.account : (await this.defaultAccount())?.accountId;
        if (!account) {
            throw new Error('Unable to resolve AWS account to use. It must be either configured when you define your CDK Stack, or through the environment');
        }
        return {
            region,
            account,
            name: cxapi.EnvironmentUtils.format(account, region),
        };
    }
    /**
     * The account we'd auth into if we used default credentials.
     *
     * Default credentials are the set of ambiently configured credentials using
     * one of the environment variables, or ~/.aws/credentials, or the *one*
     * profile that was passed into the CLI.
     *
     * Might return undefined if there are no default/ambient credentials
     * available (in which case the user should better hope they have
     * credential plugins configured).
     *
     * Uses a cache to avoid STS calls if we don't need 'em.
     */
    defaultAccount() {
        return (0, cached_1.cached)(this, CACHED_ACCOUNT, async () => {
            try {
                const creds = await this.defaultCredentials();
                const accessKeyId = creds.accessKeyId;
                if (!accessKeyId) {
                    throw new Error('Unable to resolve AWS credentials (setup with "aws configure")');
                }
                return await new sdk_1.SDK(creds, this.defaultRegion, this.sdkOptions).currentAccount();
            }
            catch (e) {
                // Treat 'ExpiredToken' specially. This is a common situation that people may find themselves in, and
                // they are complaining about if we fail 'cdk synth' on them. We loudly complain in order to show that
                // the current situation is probably undesirable, but we don't fail.
                if (e.code === 'ExpiredToken') {
                    (0, _env_1.warning)('There are expired AWS credentials in your environment. The CDK app will synth without current account information.');
                    return undefined;
                }
                (0, _env_1.debug)(`Unable to determine the default AWS account (${e.code}): ${e.message}`);
                return undefined;
            }
        });
    }
    /**
     * Get credentials for the given account ID in the given mode
     *
     * 1. Use the default credentials if the destination account matches the
     *    current credentials' account.
     * 2. Otherwise try all credential plugins.
     * 3. Fail if neither of these yield any credentials.
     * 4. Return a failure if any of them returned credentials
     */
    async obtainBaseCredentials(accountId, mode) {
        // First try 'current' credentials
        const defaultAccountId = (await this.defaultAccount())?.accountId;
        if (defaultAccountId === accountId) {
            return { source: 'correctDefault', credentials: await this.defaultCredentials() };
        }
        // Then try the plugins
        const pluginCreds = await this.plugins.fetchCredentialsFor(accountId, mode);
        if (pluginCreds) {
            return { source: 'plugin', ...pluginCreds };
        }
        // Fall back to default credentials with a note that they're not the right ones yet
        if (defaultAccountId !== undefined) {
            return {
                source: 'incorrectDefault',
                accountId: defaultAccountId,
                credentials: await this.defaultCredentials(),
                unusedPlugins: this.plugins.availablePluginNames,
            };
        }
        // Apparently we didn't find any at all
        return {
            source: 'none',
            unusedPlugins: this.plugins.availablePluginNames,
        };
    }
    /**
     * Resolve the default chain to the first set of credentials that is available
     */
    defaultCredentials() {
        return (0, cached_1.cached)(this, CACHED_DEFAULT_CREDENTIALS, () => {
            (0, _env_1.debug)('Resolving default credentials');
            return this.defaultChain.resolvePromise();
        });
    }
    /**
     * Return an SDK which uses assumed role credentials
     *
     * The base credentials used to retrieve the assumed role credentials will be the
     * same credentials returned by obtainCredentials if an environment and mode is passed,
     * otherwise it will be the current credentials.
     */
    async withAssumedRole(masterCredentials, roleArn, externalId, region) {
        (0, _env_1.debug)(`Assuming role '${roleArn}'.`);
        region = region ?? this.defaultRegion;
        const creds = new AWS.ChainableTemporaryCredentials({
            params: {
                RoleArn: roleArn,
                ...externalId ? { ExternalId: externalId } : {},
                RoleSessionName: `aws-cdk-${safeUsername()}`,
            },
            stsConfig: {
                region,
                ...this.sdkOptions,
            },
            masterCredentials: masterCredentials.credentials,
        });
        return new sdk_1.SDK(creds, region, this.sdkOptions, {
            assumeRoleCredentialsSourceDescription: fmtObtainedCredentials(masterCredentials),
        });
    }
};
SdkProvider = SdkProvider_1 = __decorate([
    tracing_1.traceMethods
], SdkProvider);
exports.SdkProvider = SdkProvider;
const DEFAULT_CONNECTION_TIMEOUT = 10000;
const DEFAULT_TIMEOUT = 300000;
/**
 * Get HTTP options for the SDK
 *
 * Read from user input or environment variables.
 *
 * Returns a complete `ConfigurationOptions` object because that's where
 * `customUserAgent` lives, but `httpOptions` is the most important attribute.
 */
function parseHttpOptions(options) {
    const config = {};
    config.httpOptions = {};
    config.httpOptions.connectTimeout = DEFAULT_CONNECTION_TIMEOUT;
    config.httpOptions.timeout = DEFAULT_TIMEOUT;
    let userAgent = options.userAgent;
    if (userAgent == null) {
        userAgent = defaultCliUserAgent();
    }
    config.customUserAgent = userAgent;
    const caBundlePath = options.caBundlePath || caBundlePathFromEnvironment();
    if (caBundlePath) {
        (0, _env_1.debug)('Using CA bundle path: %s', caBundlePath);
        config.httpOptions.ca = readIfPossible(caBundlePath);
    }
    if (options.proxyAddress) {
        (0, _env_1.debug)('Proxy server from command-line arguments: %s', options.proxyAddress);
    }
    // Configure the proxy agent. By default, this will use HTTPS?_PROXY and
    // NO_PROXY environment variables to determine which proxy to use for each
    // request.
    //
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const ProxyAgent = require('proxy-agent');
    config.httpOptions.agent = new ProxyAgent(options.proxyAddress);
    return config;
}
/**
 * Find the package.json from the main toolkit.
 *
 * If we can't read it for some reason, try to do something reasonable anyway.
 * Fall back to argv[1], or a standard string if that is undefined for some reason.
 */
function defaultCliUserAgent() {
    const root = (0, directories_1.rootDir)(false);
    const pkg = JSON.parse((root ? readIfPossible(path.join(root, 'package.json')) : undefined) ?? '{}');
    const name = pkg.name ?? path.basename(process.argv[1] ?? 'cdk-cli');
    const version = pkg.version ?? '<unknown>';
    return `${name}/${version}`;
}
exports.defaultCliUserAgent = defaultCliUserAgent;
/**
 * Find and return a CA certificate bundle path to be passed into the SDK.
 */
function caBundlePathFromEnvironment() {
    if (process.env.aws_ca_bundle) {
        return process.env.aws_ca_bundle;
    }
    if (process.env.AWS_CA_BUNDLE) {
        return process.env.AWS_CA_BUNDLE;
    }
    return undefined;
}
/**
 * Read a file if it exists, or return undefined
 *
 * Not async because it is used in the constructor
 */
function readIfPossible(filename) {
    try {
        if (!fs.pathExistsSync(filename)) {
            return undefined;
        }
        return fs.readFileSync(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        (0, _env_1.debug)(e);
        return undefined;
    }
}
/**
 * Return the username with characters invalid for a RoleSessionName removed
 *
 * @see https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html#API_AssumeRole_RequestParameters
 */
function safeUsername() {
    try {
        return os.userInfo().username.replace(/[^\w+=,.@-]/g, '@');
    }
    catch {
        return 'noname';
    }
}
/**
 * Isolating the code that translates calculation errors into human error messages
 *
 * We cover the following cases:
 *
 * - No credentials are available at all
 * - Default credentials are for the wrong account
 */
function fmtObtainCredentialsError(targetAccountId, obtainResult) {
    const msg = [`Need to perform AWS calls for account ${targetAccountId}`];
    switch (obtainResult.source) {
        case 'incorrectDefault':
            msg.push(`but the current credentials are for ${obtainResult.accountId}`);
            break;
        case 'none':
            msg.push('but no credentials have been configured');
    }
    if (obtainResult.unusedPlugins.length > 0) {
        msg.push(`and none of these plugins found any: ${obtainResult.unusedPlugins.join(', ')}`);
    }
    return msg.join(', ');
}
/**
 * Format a message indicating where we got base credentials for the assume role
 *
 * We cover the following cases:
 *
 * - Default credentials for the right account
 * - Default credentials for the wrong account
 * - Credentials returned from a plugin
 */
function fmtObtainedCredentials(obtainResult) {
    switch (obtainResult.source) {
        case 'correctDefault':
            return 'current credentials';
        case 'plugin':
            return `credentials returned by plugin '${obtainResult.pluginName}'`;
        case 'incorrectDefault':
            const msg = [];
            msg.push(`current credentials (which are for account ${obtainResult.accountId}`);
            if (obtainResult.unusedPlugins.length > 0) {
                msg.push(`, and none of the following plugins provided credentials: ${obtainResult.unusedPlugins.join(', ')}`);
            }
            msg.push(')');
            return msg.join('');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLXByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLXByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLHlDQUF5QztBQUN6QywrQkFBK0I7QUFFL0IsK0JBQStCO0FBQy9CLGlDQUF3QztBQUN4QywyREFBdUQ7QUFDdkQscUNBQWtDO0FBQ2xDLDZEQUF5RDtBQUV6RCwrQkFBMkQ7QUFDM0Qsd0RBQWlEO0FBQ2pELGdEQUFrRDtBQUdsRCwwREFBMEQ7QUFDMUQseUJBQXlCO0FBQ3pCLE9BQU8sQ0FBQyxHQUFHLENBQUMsMEJBQTBCLEdBQUcsVUFBVSxDQUFDO0FBQ3BELE9BQU8sQ0FBQyxHQUFHLENBQUMsbUNBQW1DLEdBQUcsR0FBRyxDQUFDO0FBMkR0RCxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUNoRCxNQUFNLDBCQUEwQixHQUFHLE1BQU0sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO0FBNkJ4RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRztBQUVJLElBQU0sV0FBVyxtQkFBakIsTUFBTSxXQUFXO0lBQ3RCOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxVQUE4QixFQUFFO1FBQy9FLE1BQU0sVUFBVSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDLENBQUM7UUFFL0QsTUFBTSxLQUFLLEdBQUcsTUFBTSxvQ0FBZ0IsQ0FBQyxlQUFlLENBQUM7WUFDbkQsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPO1lBQ3hCLFdBQVcsRUFBRSxPQUFPLENBQUMsUUFBUTtZQUM3QixjQUFjLEVBQUUsT0FBTyxDQUFDLGNBQWM7WUFDdEMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxXQUFXO1NBQ3BDLENBQUMsQ0FBQztRQUNILE1BQU0sTUFBTSxHQUFHLE1B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QyxHQUFHLENBQUMsSUFBSSxDQUFDLDZEQUE2RCxZQUFZLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDaEg7WUFDRCxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRWQsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQ3ZCO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHR5cGUgeyBDb25maWd1cmF0aW9uT3B0aW9ucyB9IGZyb20gJ2F3cy1zZGsvbGliL2NvbmZpZy1iYXNlJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB7IGRlYnVnLCB3YXJuaW5nIH0gZnJvbSAnLi9fZW52JztcbmltcG9ydCB7IEF3c0NsaUNvbXBhdGlibGUgfSBmcm9tICcuL2F3c2NsaS1jb21wYXRpYmxlJztcbmltcG9ydCB7IGNhY2hlZCB9IGZyb20gJy4vY2FjaGVkJztcbmltcG9ydCB7IENyZWRlbnRpYWxQbHVnaW5zIH0gZnJvbSAnLi9jcmVkZW50aWFsLXBsdWdpbnMnO1xuaW1wb3J0IHsgTW9kZSB9IGZyb20gJy4vY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgSVNESywgU0RLLCBpc1VucmVjb3ZlcmFibGVBd3NFcnJvciB9IGZyb20gJy4vc2RrJztcbmltcG9ydCB7IHJvb3REaXIgfSBmcm9tICcuLi8uLi91dGlsL2RpcmVjdG9yaWVzJztcbmltcG9ydCB7IHRyYWNlTWV0aG9kcyB9IGZyb20gJy4uLy4uL3V0aWwvdHJhY2luZyc7XG5cblxuLy8gU29tZSBjb25maWd1cmF0aW9uIHRoYXQgY2FuIG9ubHkgYmUgYWNoaWV2ZWQgYnkgc2V0dGluZ1xuLy8gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxucHJvY2Vzcy5lbnYuQVdTX1NUU19SRUdJT05BTF9FTkRQT0lOVFMgPSAncmVnaW9uYWwnO1xucHJvY2Vzcy5lbnYuQVdTX05PREVKU19DT05ORUNUSU9OX1JFVVNFX0VOQUJMRUQgPSAnMSc7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIGRlZmF1bHQgU0RLIHByb3ZpZGVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2RrUHJvdmlkZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIFByb2ZpbGUgdG8gcmVhZCBmcm9tIH4vLmF3c1xuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIHByb2ZpbGVcbiAgICovXG4gIHJlYWRvbmx5IHByb2ZpbGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgd2Ugc2hvdWxkIGNoZWNrIGZvciBFQzIgY3JlZGVudGlhbHNcbiAgICpcbiAgICogQGRlZmF1bHQgLSBBdXRvZGV0ZWN0XG4gICAqL1xuICByZWFkb25seSBlYzJjcmVkcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgd2Ugc2hvdWxkIGNoZWNrIGZvciBjb250YWluZXIgY3JlZGVudGlhbHNcbiAgICpcbiAgICogQGRlZmF1bHQgLSBBdXRvZGV0ZWN0XG4gICAqL1xuICByZWFkb25seSBjb250YWluZXJDcmVkcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEhUVFAgb3B0aW9ucyBmb3IgU0RLXG4gICAqL1xuICByZWFkb25seSBodHRwT3B0aW9ucz86IFNka0h0dHBPcHRpb25zO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGluZGl2aWR1YWwgU0RLc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNka0h0dHBPcHRpb25zIHtcbiAgLyoqXG4gICAqIFByb3h5IGFkZHJlc3MgdG8gdXNlXG4gICAqXG4gICAqIEBkZWZhdWx0IE5vIHByb3h5XG4gICAqL1xuICByZWFkb25seSBwcm94eUFkZHJlc3M/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgcGF0aCB0byBhIGNlcnRpZmljYXRlIGJ1bmRsZSB0aGF0IGNvbnRhaW5zIGEgY2VydCB0byBiZSB0cnVzdGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBObyBjZXJ0aWZpY2F0ZSBidW5kbGVcbiAgICovXG4gIHJlYWRvbmx5IGNhQnVuZGxlUGF0aD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGN1c3RvbSB1c2VyIGFnZW50IHRvIHVzZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSA8cGFja2FnZS1uYW1lPi88cGFja2FnZS12ZXJzaW9uPlxuICAgKi9cbiAgcmVhZG9ubHkgdXNlckFnZW50Pzogc3RyaW5nO1xufVxuXG5jb25zdCBDQUNIRURfQUNDT1VOVCA9IFN5bWJvbCgnY2FjaGVkX2FjY291bnQnKTtcbmNvbnN0IENBQ0hFRF9ERUZBVUxUX0NSRURFTlRJQUxTID0gU3ltYm9sKCdjYWNoZWRfZGVmYXVsdF9jcmVkZW50aWFscycpO1xuXG4vKipcbiAqIFNESyBjb25maWd1cmF0aW9uIGZvciBhIGdpdmVuIGVudmlyb25tZW50XG4gKiAnZm9yRW52aXJvbm1lbnQnIHdpbGwgYXR0ZW1wdCB0byBhc3N1bWUgYSByb2xlIGFuZCBpZiBpdFxuICogaXMgbm90IHN1Y2Nlc3NmdWwsIHRoZW4gaXQgd2lsbCBlaXRoZXI6XG4gKiAgIDEuIENoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdCBjcmVkZW50aWFscyAobG9jYWwgY3JlZGVudGlhbHMgdGhlIENMSSB3YXMgZXhlY3V0ZWQgd2l0aClcbiAqICAgICAgYXJlIGZvciB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQuIElmIHRoZXkgYXJlIHRoZW4gcmV0dXJuIHRob3NlLlxuICogICAyLiBJZiB0aGUgZGVmYXVsdCBjcmVkZW50aWFscyBhcmUgbm90IGZvciB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQgdGhlblxuICogICAgICB0aHJvdyBhbiBlcnJvclxuICpcbiAqICdkaWRBc3N1bWVSb2xlJyBhbGxvd3MgY2FsbGVycyB0byB3aGV0aGVyIHRoZXkgYXJlIHJlY2VpdmluZyB0aGUgYXNzdW1lIHJvbGVcbiAqIGNyZWRlbnRpYWxzIG9yIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNka0ZvckVudmlyb25tZW50IHtcbiAgLyoqXG4gICAqIFRoZSBTREsgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudFxuICAgKi9cbiAgcmVhZG9ubHkgc2RrOiBJU0RLO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgYXNzdW1lIHJvbGUgd2FzIHN1Y2Nlc3NmdWwuXG4gICAqIElmIHRoZSBhc3N1bWUgcm9sZSB3YXMgbm90IHN1Y2Nlc3NmdWwgKGZhbHNlKVxuICAgKiB0aGVuIHRoYXQgbWVhbnMgdGhhdCB0aGUgJ3NkaycgcmV0dXJuZWQgY29udGFpbnNcbiAgICogdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMgKG5vdCB0aGUgYXNzdW1lIHJvbGUgY3JlZGVudGlhbHMpXG4gICAqL1xuICByZWFkb25seSBkaWRBc3N1bWVSb2xlOiBib29sZWFuO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgaW5zdGFuY2VzIG9mIHRoZSBBV1MgU0RLIGFwcHJvcHJpYXRlIGZvciBhIGdpdmVuIGFjY291bnQvcmVnaW9uLlxuICpcbiAqIEJlaGF2aW9yIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogLSBGaXJzdCwgYSBzZXQgb2YgXCJiYXNlXCIgY3JlZGVudGlhbHMgYXJlIGVzdGFibGlzaGVkXG4gKiAgIC0gSWYgYSB0YXJnZXQgZW52aXJvbm1lbnQgaXMgZ2l2ZW4gYW5kIHRoZSBkZWZhdWx0IChcImN1cnJlbnRcIikgU0RLIGNyZWRlbnRpYWxzIGFyZSBmb3JcbiAqICAgICB0aGF0IGFjY291bnQsIHJldHVybiB0aG9zZTsgb3RoZXJ3aXNlXG4gKiAgIC0gSWYgYSB0YXJnZXQgZW52aXJvbm1lbnQgaXMgZ2l2ZW4sIHNjYW4gYWxsIGNyZWRlbnRpYWwgcHJvdmlkZXIgcGx1Z2luc1xuICogICAgIGZvciBjcmVkZW50aWFscywgYW5kIHJldHVybiB0aG9zZSBpZiBmb3VuZDsgb3RoZXJ3aXNlXG4gKiAgIC0gUmV0dXJuIGRlZmF1bHQgKFwiY3VycmVudFwiKSBTREsgY3JlZGVudGlhbHMsIG5vdGluZyB0aGF0IHRoZXkgbWlnaHQgYmUgd3JvbmcuXG4gKlxuICogLSBTZWNvbmQsIGEgcm9sZSBtYXkgb3B0aW9uYWxseSBuZWVkIHRvIGJlIGFzc3VtZWQuIFVzZSB0aGUgYmFzZSBjcmVkZW50aWFsc1xuICogICBlc3RhYmxpc2hlZCBpbiB0aGUgcHJldmlvdXMgcHJvY2VzcyB0byBhc3N1bWUgdGhhdCByb2xlLlxuICogICAtIElmIGFzc3VtaW5nIHRoZSByb2xlIGZhaWxzIGFuZCB0aGUgYmFzZSBjcmVkZW50aWFscyBhcmUgZm9yIHRoZSBjb3JyZWN0XG4gKiAgICAgYWNjb3VudCwgcmV0dXJuIHRob3NlLiBUaGlzIGlzIGEgZmFsbGJhY2sgZm9yIHBlb3BsZSB3aG8gYXJlIHRyeWluZyB0byBpbnRlcmFjdFxuICogICAgIHdpdGggYSBEZWZhdWx0IFN5bnRoZXNpemVkIHN0YWNrIGFuZCBhbHJlYWR5IGhhdmUgcmlnaHQgY3JlZGVudGlhbHMgc2V0dXAuXG4gKlxuICogICAgIFR5cGljYWwgY2FzZXMgd2Ugc2VlIGluIHRoZSB3aWxkOlxuICogICAgIC0gQ3JlZGVudGlhbCBwbHVnaW4gc2V0dXAgdGhhdCwgYWx0aG91Z2ggbm90IHJlY29tbWVuZGVkLCB3b3JrcyBmb3IgdGhlbVxuICogICAgIC0gU2VlZGVkIHRlcm1pbmFsIHdpdGggYFJlYWRPbmx5YCBjcmVkZW50aWFscyBpbiBvcmRlciB0byBkbyBgY2RrIGRpZmZgLS10aGUgYFJlYWRPbmx5YFxuICogICAgICAgcm9sZSBkb2Vzbid0IGhhdmUgYHN0czpBc3N1bWVSb2xlYCBhbmQgd2lsbCBmYWlsIGZvciBubyByZWFsIGdvb2QgcmVhc29uLlxuICovXG5AdHJhY2VNZXRob2RzXG5leHBvcnQgY2xhc3MgU2RrUHJvdmlkZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFNka1Byb3ZpZGVyIHdoaWNoIGdldHMgaXRzIGRlZmF1bHRzIGluIGEgd2F5IHRoYXQgYmVoYXZlcyBsaWtlIHRoZSBBV1MgQ0xJIGRvZXNcbiAgICpcbiAgICogVGhlIEFXUyBTREsgZm9yIEpTIGJlaGF2ZXMgc2xpZ2h0bHkgZGlmZmVyZW50bHkgZnJvbSB0aGUgQVdTIENMSSBpbiBhIG51bWJlciBvZiB3YXlzOyBzZWUgdGhlXG4gICAqIGNsYXNzIGBBd3NDbGlDb21wYXRpYmxlYCBmb3IgdGhlIGRldGFpbHMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIHdpdGhBd3NDbGlDb21wYXRpYmxlRGVmYXVsdHMob3B0aW9uczogU2RrUHJvdmlkZXJPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzZGtPcHRpb25zID0gcGFyc2VIdHRwT3B0aW9ucyhvcHRpb25zLmh0dHBPcHRpb25zID8/IHt9KTtcblxuICAgIGNvbnN0IGNoYWluID0gYXdhaXQgQXdzQ2xpQ29tcGF0aWJsZS5jcmVkZW50aWFsQ2hhaW4oe1xuICAgICAgcHJvZmlsZTogb3B0aW9ucy5wcm9maWxlLFxuICAgICAgZWMyaW5zdGFuY2U6IG9wdGlvbnMuZWMyY3JlZHMsXG4gICAgICBjb250YWluZXJDcmVkczogb3B0aW9ucy5jb250YWluZXJDcmVkcyxcbiAgICAgIGh0dHBPcHRpb25zOiBzZGtPcHRpb25zLmh0dHBPcHRpb25zLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlZ2lvbiA9IGF3YWl0IEF3c0NsaUNvbXBhdGlibGUucmVnaW9uKHtcbiAgICAgIHByb2ZpbGU6IG9wdGlvbnMucHJvZmlsZSxcbiAgICAgIGVjMmluc3RhbmNlOiBvcHRpb25zLmVjMmNyZWRzLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBTZGtQcm92aWRlcihjaGFpbiwgcmVnaW9uLCBzZGtPcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgcGx1Z2lucyA9IG5ldyBDcmVkZW50aWFsUGx1Z2lucygpO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRDaGFpbjogQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLFxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgcmVnaW9uXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IGRlZmF1bHRSZWdpb246IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNka09wdGlvbnM6IENvbmZpZ3VyYXRpb25PcHRpb25zID0ge30pIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gU0RLIHdoaWNoIGNhbiBkbyBvcGVyYXRpb25zIGluIHRoZSBnaXZlbiBlbnZpcm9ubWVudFxuICAgKlxuICAgKiBUaGUgYGVudmlyb25tZW50YCBwYXJhbWV0ZXIgaXMgcmVzb2x2ZWQgZmlyc3QgKHNlZSBgcmVzb2x2ZUVudmlyb25tZW50KClgKS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBmb3JFbnZpcm9ubWVudChcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgbW9kZTogTW9kZSxcbiAgICBvcHRpb25zPzogQ3JlZGVudGlhbHNPcHRpb25zLFxuICApOiBQcm9taXNlPFNka0ZvckVudmlyb25tZW50PiB7XG4gICAgY29uc3QgZW52ID0gYXdhaXQgdGhpcy5yZXNvbHZlRW52aXJvbm1lbnQoZW52aXJvbm1lbnQpO1xuICAgIGNvbnN0IGJhc2VDcmVkcyA9IGF3YWl0IHRoaXMub2J0YWluQmFzZUNyZWRlbnRpYWxzKGVudi5hY2NvdW50LCBtb2RlKTtcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgYXQgbGVhc3QgU09NRSBjcmVkZW50aWFsc1xuICAgIGlmIChiYXNlQ3JlZHMuc291cmNlID09PSAnbm9uZScpIHsgdGhyb3cgbmV3IEVycm9yKGZtdE9idGFpbkNyZWRlbnRpYWxzRXJyb3IoZW52LmFjY291bnQsIGJhc2VDcmVkcykpOyB9XG5cbiAgICAvLyBTaW1wbGUgY2FzZSBpcyBpZiB3ZSBkb24ndCBuZWVkIHRvIFwiYXNzdW1lUm9sZVwiIGhlcmUuIElmIHNvLCB3ZSBtdXN0IG5vdyBoYXZlIGNyZWRlbnRpYWxzIGZvciB0aGUgcmlnaHRcbiAgICAvLyBhY2NvdW50LlxuICAgIGlmIChvcHRpb25zPy5hc3N1bWVSb2xlQXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChiYXNlQ3JlZHMuc291cmNlID09PSAnaW5jb3JyZWN0RGVmYXVsdCcpIHsgdGhyb3cgbmV3IEVycm9yKGZtdE9idGFpbkNyZWRlbnRpYWxzRXJyb3IoZW52LmFjY291bnQsIGJhc2VDcmVkcykpOyB9XG5cbiAgICAgIC8vIE91ciBjdXJyZW50IGNyZWRlbnRpYWxzIG11c3QgYmUgdmFsaWQgYW5kIG5vdCBleHBpcmVkLiBDb25maXJtIHRoYXQgYmVmb3JlIHdlIGdldCBpbnRvIGRvaW5nXG4gICAgICAvLyBhY3R1YWwgQ2xvdWRGb3JtYXRpb24gY2FsbHMsIHdoaWNoIG1pZ2h0IHRha2UgYSBsb25nIHRpbWUgdG8gaGFuZy5cbiAgICAgIGNvbnN0IHNkayA9IG5ldyBTREsoYmFzZUNyZWRzLmNyZWRlbnRpYWxzLCBlbnYucmVnaW9uLCB0aGlzLnNka09wdGlvbnMpO1xuICAgICAgYXdhaXQgc2RrLnZhbGlkYXRlQ3JlZGVudGlhbHMoKTtcbiAgICAgIHJldHVybiB7IHNkaywgZGlkQXNzdW1lUm9sZTogZmFsc2UgfTtcbiAgICB9XG5cbiAgICAvLyBXZSB3aWxsIHByb2NlZWQgdG8gQXNzdW1lUm9sZSB1c2luZyB3aGF0ZXZlciB3ZSd2ZSBiZWVuIGdpdmVuLlxuICAgIGNvbnN0IHNkayA9IGF3YWl0IHRoaXMud2l0aEFzc3VtZWRSb2xlKGJhc2VDcmVkcywgb3B0aW9ucy5hc3N1bWVSb2xlQXJuLCBvcHRpb25zLmFzc3VtZVJvbGVFeHRlcm5hbElkLCBlbnYucmVnaW9uKTtcblxuICAgIC8vIEV4ZXJjaXNlIHRoZSBBc3N1bWVSb2xlQ3JlZGVudGlhbHNQcm92aWRlciB3ZSd2ZSBnb3R0ZW4gYXQgbGVhc3Qgb25jZSBzb1xuICAgIC8vIHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0aGUgQXNzdW1lUm9sZSBjYWxsIHN1Y2NlZWRzIG9yIG5vdC5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2RrLmZvcmNlQ3JlZGVudGlhbFJldHJpZXZhbCgpO1xuICAgICAgcmV0dXJuIHsgc2RrLCBkaWRBc3N1bWVSb2xlOiB0cnVlIH07XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoaXNVbnJlY292ZXJhYmxlQXdzRXJyb3IoZSkpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgLy8gQXNzdW1lUm9sZSBmYWlsZWQuIFByb2NlZWQgYW5kIHdhcm4gKmlmIGFuZCBvbmx5IGlmKiB0aGUgYmFzZUNyZWRlbnRpYWxzIHdlcmUgYWxyZWFkeSBmb3IgdGhlIHJpZ2h0IGFjY291bnRcbiAgICAgIC8vIG9yIHJldHVybmVkIGZyb20gYSBwbHVnaW4uIFRoaXMgaXMgdG8gY292ZXIgc29tZSBjdXJyZW50IHNldHVwcyBmb3IgcGVvcGxlIHVzaW5nIHBsdWdpbnMgb3IgcHJlZmVycmluZyB0b1xuICAgICAgLy8gZmVlZCB0aGUgQ0xJIGNyZWRlbnRpYWxzIHdoaWNoIGFyZSBzdWZmaWNpZW50IGJ5IHRoZW1zZWx2ZXMuIFByZWZlciB0byBhc3N1bWUgdGhlIGNvcnJlY3Qgcm9sZSBpZiB3ZSBjYW4sXG4gICAgICAvLyBidXQgaWYgd2UgY2FuJ3QgdGhlbiBsZXQncyBqdXN0IHRyeSB3aXRoIGF2YWlsYWJsZSBjcmVkZW50aWFscyBhbnl3YXkuXG4gICAgICBpZiAoYmFzZUNyZWRzLnNvdXJjZSA9PT0gJ2NvcnJlY3REZWZhdWx0JyB8fCBiYXNlQ3JlZHMuc291cmNlID09PSAncGx1Z2luJykge1xuICAgICAgICBkZWJ1ZyhlLm1lc3NhZ2UpO1xuICAgICAgICB3YXJuaW5nKGAke2ZtdE9idGFpbmVkQ3JlZGVudGlhbHMoYmFzZUNyZWRzKX0gY291bGQgbm90IGJlIHVzZWQgdG8gYXNzdW1lICcke29wdGlvbnMuYXNzdW1lUm9sZUFybn0nLCBidXQgYXJlIGZvciB0aGUgcmlnaHQgYWNjb3VudC4gUHJvY2VlZGluZyBhbnl3YXkuYCk7XG4gICAgICAgIHJldHVybiB7IHNkazogbmV3IFNESyhiYXNlQ3JlZHMuY3JlZGVudGlhbHMsIGVudi5yZWdpb24sIHRoaXMuc2RrT3B0aW9ucyksIGRpZEFzc3VtZVJvbGU6IGZhbHNlIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcGFydGl0aW9uIHRoYXQgYmFzZSBjcmVkZW50aWFscyBhcmUgZm9yXG4gICAqXG4gICAqIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlcmUgYXJlIG5vIGJhc2UgY3JlZGVudGlhbHMuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYmFzZUNyZWRlbnRpYWxzUGFydGl0aW9uKGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgbW9kZTogTW9kZSk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgZW52ID0gYXdhaXQgdGhpcy5yZXNvbHZlRW52aXJvbm1lbnQoZW52aXJvbm1lbnQpO1xuICAgIGNvbnN0IGJhc2VDcmVkcyA9IGF3YWl0IHRoaXMub2J0YWluQmFzZUNyZWRlbnRpYWxzKGVudi5hY2NvdW50LCBtb2RlKTtcbiAgICBpZiAoYmFzZUNyZWRzLnNvdXJjZSA9PT0gJ25vbmUnKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICByZXR1cm4gKGF3YWl0IG5ldyBTREsoYmFzZUNyZWRzLmNyZWRlbnRpYWxzLCBlbnYucmVnaW9uLCB0aGlzLnNka09wdGlvbnMpLmN1cnJlbnRBY2NvdW50KCkpLnBhcnRpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBlbnZpcm9ubWVudCBmb3IgYSBzdGFja1xuICAgKlxuICAgKiBSZXBsYWNlcyB0aGUgbWFnaWMgdmFsdWVzIGBVTktOT1dOX1JFR0lPTmAgYW5kIGBVTktOT1dOX0FDQ09VTlRgXG4gICAqIHdpdGggdGhlIGRlZmF1bHRzIGZvciB0aGUgY3VycmVudCBTREsgY29uZmlndXJhdGlvbiAoYH4vLmF3cy9jb25maWdgIG9yXG4gICAqIG90aGVyd2lzZSkuXG4gICAqXG4gICAqIEl0IGlzIGFuIGVycm9yIGlmIGBVTktOT1dOX0FDQ09VTlRgIGlzIHVzZWQgYnV0IHRoZSB1c2VyIGhhc24ndCBjb25maWd1cmVkXG4gICAqIGFueSBTREsgY3JlZGVudGlhbHMuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcmVzb2x2ZUVudmlyb25tZW50KGVudjogY3hhcGkuRW52aXJvbm1lbnQpOiBQcm9taXNlPGN4YXBpLkVudmlyb25tZW50PiB7XG4gICAgY29uc3QgcmVnaW9uID0gZW52LnJlZ2lvbiAhPT0gY3hhcGkuVU5LTk9XTl9SRUdJT04gPyBlbnYucmVnaW9uIDogdGhpcy5kZWZhdWx0UmVnaW9uO1xuICAgIGNvbnN0IGFjY291bnQgPSBlbnYuYWNjb3VudCAhPT0gY3hhcGkuVU5LTk9XTl9BQ0NPVU5UID8gZW52LmFjY291bnQgOiAoYXdhaXQgdGhpcy5kZWZhdWx0QWNjb3VudCgpKT8uYWNjb3VudElkO1xuXG4gICAgaWYgKCFhY2NvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZXNvbHZlIEFXUyBhY2NvdW50IHRvIHVzZS4gSXQgbXVzdCBiZSBlaXRoZXIgY29uZmlndXJlZCB3aGVuIHlvdSBkZWZpbmUgeW91ciBDREsgU3RhY2ssIG9yIHRocm91Z2ggdGhlIGVudmlyb25tZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lvbixcbiAgICAgIGFjY291bnQsXG4gICAgICBuYW1lOiBjeGFwaS5FbnZpcm9ubWVudFV0aWxzLmZvcm1hdChhY2NvdW50LCByZWdpb24pLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGFjY291bnQgd2UnZCBhdXRoIGludG8gaWYgd2UgdXNlZCBkZWZhdWx0IGNyZWRlbnRpYWxzLlxuICAgKlxuICAgKiBEZWZhdWx0IGNyZWRlbnRpYWxzIGFyZSB0aGUgc2V0IG9mIGFtYmllbnRseSBjb25maWd1cmVkIGNyZWRlbnRpYWxzIHVzaW5nXG4gICAqIG9uZSBvZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLCBvciB+Ly5hd3MvY3JlZGVudGlhbHMsIG9yIHRoZSAqb25lKlxuICAgKiBwcm9maWxlIHRoYXQgd2FzIHBhc3NlZCBpbnRvIHRoZSBDTEkuXG4gICAqXG4gICAqIE1pZ2h0IHJldHVybiB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIGRlZmF1bHQvYW1iaWVudCBjcmVkZW50aWFsc1xuICAgKiBhdmFpbGFibGUgKGluIHdoaWNoIGNhc2UgdGhlIHVzZXIgc2hvdWxkIGJldHRlciBob3BlIHRoZXkgaGF2ZVxuICAgKiBjcmVkZW50aWFsIHBsdWdpbnMgY29uZmlndXJlZCkuXG4gICAqXG4gICAqIFVzZXMgYSBjYWNoZSB0byBhdm9pZCBTVFMgY2FsbHMgaWYgd2UgZG9uJ3QgbmVlZCAnZW0uXG4gICAqL1xuICBwdWJsaWMgZGVmYXVsdEFjY291bnQoKTogUHJvbWlzZTxBY2NvdW50IHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIGNhY2hlZCh0aGlzLCBDQUNIRURfQUNDT1VOVCwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3JlZHMgPSBhd2FpdCB0aGlzLmRlZmF1bHRDcmVkZW50aWFscygpO1xuXG4gICAgICAgIGNvbnN0IGFjY2Vzc0tleUlkID0gY3JlZHMuYWNjZXNzS2V5SWQ7XG4gICAgICAgIGlmICghYWNjZXNzS2V5SWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZXNvbHZlIEFXUyBjcmVkZW50aWFscyAoc2V0dXAgd2l0aCBcImF3cyBjb25maWd1cmVcIiknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBuZXcgU0RLKGNyZWRzLCB0aGlzLmRlZmF1bHRSZWdpb24sIHRoaXMuc2RrT3B0aW9ucykuY3VycmVudEFjY291bnQoKTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAvLyBUcmVhdCAnRXhwaXJlZFRva2VuJyBzcGVjaWFsbHkuIFRoaXMgaXMgYSBjb21tb24gc2l0dWF0aW9uIHRoYXQgcGVvcGxlIG1heSBmaW5kIHRoZW1zZWx2ZXMgaW4sIGFuZFxuICAgICAgICAvLyB0aGV5IGFyZSBjb21wbGFpbmluZyBhYm91dCBpZiB3ZSBmYWlsICdjZGsgc3ludGgnIG9uIHRoZW0uIFdlIGxvdWRseSBjb21wbGFpbiBpbiBvcmRlciB0byBzaG93IHRoYXRcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgc2l0dWF0aW9uIGlzIHByb2JhYmx5IHVuZGVzaXJhYmxlLCBidXQgd2UgZG9uJ3QgZmFpbC5cbiAgICAgICAgaWYgKGUuY29kZSA9PT0gJ0V4cGlyZWRUb2tlbicpIHtcbiAgICAgICAgICB3YXJuaW5nKCdUaGVyZSBhcmUgZXhwaXJlZCBBV1MgY3JlZGVudGlhbHMgaW4geW91ciBlbnZpcm9ubWVudC4gVGhlIENESyBhcHAgd2lsbCBzeW50aCB3aXRob3V0IGN1cnJlbnQgYWNjb3VudCBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcoYFVuYWJsZSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgQVdTIGFjY291bnQgKCR7ZS5jb2RlfSk6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjcmVkZW50aWFscyBmb3IgdGhlIGdpdmVuIGFjY291bnQgSUQgaW4gdGhlIGdpdmVuIG1vZGVcbiAgICpcbiAgICogMS4gVXNlIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzIGlmIHRoZSBkZXN0aW5hdGlvbiBhY2NvdW50IG1hdGNoZXMgdGhlXG4gICAqICAgIGN1cnJlbnQgY3JlZGVudGlhbHMnIGFjY291bnQuXG4gICAqIDIuIE90aGVyd2lzZSB0cnkgYWxsIGNyZWRlbnRpYWwgcGx1Z2lucy5cbiAgICogMy4gRmFpbCBpZiBuZWl0aGVyIG9mIHRoZXNlIHlpZWxkIGFueSBjcmVkZW50aWFscy5cbiAgICogNC4gUmV0dXJuIGEgZmFpbHVyZSBpZiBhbnkgb2YgdGhlbSByZXR1cm5lZCBjcmVkZW50aWFsc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBvYnRhaW5CYXNlQ3JlZGVudGlhbHMoYWNjb3VudElkOiBzdHJpbmcsIG1vZGU6IE1vZGUpOiBQcm9taXNlPE9idGFpbkJhc2VDcmVkZW50aWFsc1Jlc3VsdD4ge1xuICAgIC8vIEZpcnN0IHRyeSAnY3VycmVudCcgY3JlZGVudGlhbHNcbiAgICBjb25zdCBkZWZhdWx0QWNjb3VudElkID0gKGF3YWl0IHRoaXMuZGVmYXVsdEFjY291bnQoKSk/LmFjY291bnRJZDtcbiAgICBpZiAoZGVmYXVsdEFjY291bnRJZCA9PT0gYWNjb3VudElkKSB7XG4gICAgICByZXR1cm4geyBzb3VyY2U6ICdjb3JyZWN0RGVmYXVsdCcsIGNyZWRlbnRpYWxzOiBhd2FpdCB0aGlzLmRlZmF1bHRDcmVkZW50aWFscygpIH07XG4gICAgfVxuXG4gICAgLy8gVGhlbiB0cnkgdGhlIHBsdWdpbnNcbiAgICBjb25zdCBwbHVnaW5DcmVkcyA9IGF3YWl0IHRoaXMucGx1Z2lucy5mZXRjaENyZWRlbnRpYWxzRm9yKGFjY291bnRJZCwgbW9kZSk7XG4gICAgaWYgKHBsdWdpbkNyZWRzKSB7XG4gICAgICByZXR1cm4geyBzb3VyY2U6ICdwbHVnaW4nLCAuLi5wbHVnaW5DcmVkcyB9O1xuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byBkZWZhdWx0IGNyZWRlbnRpYWxzIHdpdGggYSBub3RlIHRoYXQgdGhleSdyZSBub3QgdGhlIHJpZ2h0IG9uZXMgeWV0XG4gICAgaWYgKGRlZmF1bHRBY2NvdW50SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiAnaW5jb3JyZWN0RGVmYXVsdCcsXG4gICAgICAgIGFjY291bnRJZDogZGVmYXVsdEFjY291bnRJZCxcbiAgICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuZGVmYXVsdENyZWRlbnRpYWxzKCksXG4gICAgICAgIHVudXNlZFBsdWdpbnM6IHRoaXMucGx1Z2lucy5hdmFpbGFibGVQbHVnaW5OYW1lcyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQXBwYXJlbnRseSB3ZSBkaWRuJ3QgZmluZCBhbnkgYXQgYWxsXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogJ25vbmUnLFxuICAgICAgdW51c2VkUGx1Z2luczogdGhpcy5wbHVnaW5zLmF2YWlsYWJsZVBsdWdpbk5hbWVzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgZGVmYXVsdCBjaGFpbiB0byB0aGUgZmlyc3Qgc2V0IG9mIGNyZWRlbnRpYWxzIHRoYXQgaXMgYXZhaWxhYmxlXG4gICAqL1xuICBwcml2YXRlIGRlZmF1bHRDcmVkZW50aWFscygpOiBQcm9taXNlPEFXUy5DcmVkZW50aWFscz4ge1xuICAgIHJldHVybiBjYWNoZWQodGhpcywgQ0FDSEVEX0RFRkFVTFRfQ1JFREVOVElBTFMsICgpID0+IHtcbiAgICAgIGRlYnVnKCdSZXNvbHZpbmcgZGVmYXVsdCBjcmVkZW50aWFscycpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdENoYWluLnJlc29sdmVQcm9taXNlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIFNESyB3aGljaCB1c2VzIGFzc3VtZWQgcm9sZSBjcmVkZW50aWFsc1xuICAgKlxuICAgKiBUaGUgYmFzZSBjcmVkZW50aWFscyB1c2VkIHRvIHJldHJpZXZlIHRoZSBhc3N1bWVkIHJvbGUgY3JlZGVudGlhbHMgd2lsbCBiZSB0aGVcbiAgICogc2FtZSBjcmVkZW50aWFscyByZXR1cm5lZCBieSBvYnRhaW5DcmVkZW50aWFscyBpZiBhbiBlbnZpcm9ubWVudCBhbmQgbW9kZSBpcyBwYXNzZWQsXG4gICAqIG90aGVyd2lzZSBpdCB3aWxsIGJlIHRoZSBjdXJyZW50IGNyZWRlbnRpYWxzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB3aXRoQXNzdW1lZFJvbGUoXG4gICAgbWFzdGVyQ3JlZGVudGlhbHM6IEV4Y2x1ZGU8T2J0YWluQmFzZUNyZWRlbnRpYWxzUmVzdWx0LCB7IHNvdXJjZTogJ25vbmUnIH0+LFxuICAgIHJvbGVBcm46IHN0cmluZyxcbiAgICBleHRlcm5hbElkOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBkZWJ1ZyhgQXNzdW1pbmcgcm9sZSAnJHtyb2xlQXJufScuYCk7XG5cbiAgICByZWdpb24gPSByZWdpb24gPz8gdGhpcy5kZWZhdWx0UmVnaW9uO1xuXG4gICAgY29uc3QgY3JlZHMgPSBuZXcgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBSb2xlQXJuOiByb2xlQXJuLFxuICAgICAgICAuLi5leHRlcm5hbElkID8geyBFeHRlcm5hbElkOiBleHRlcm5hbElkIH0gOiB7fSxcbiAgICAgICAgUm9sZVNlc3Npb25OYW1lOiBgYXdzLWNkay0ke3NhZmVVc2VybmFtZSgpfWAsXG4gICAgICB9LFxuICAgICAgc3RzQ29uZmlnOiB7XG4gICAgICAgIHJlZ2lvbixcbiAgICAgICAgLi4udGhpcy5zZGtPcHRpb25zLFxuICAgICAgfSxcbiAgICAgIG1hc3RlckNyZWRlbnRpYWxzOiBtYXN0ZXJDcmVkZW50aWFscy5jcmVkZW50aWFscyxcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgU0RLKGNyZWRzLCByZWdpb24sIHRoaXMuc2RrT3B0aW9ucywge1xuICAgICAgYXNzdW1lUm9sZUNyZWRlbnRpYWxzU291cmNlRGVzY3JpcHRpb246IGZtdE9idGFpbmVkQ3JlZGVudGlhbHMobWFzdGVyQ3JlZGVudGlhbHMpLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQW4gQVdTIGFjY291bnRcbiAqXG4gKiBBbiBBV1MgYWNjb3VudCBhbHdheXMgZXhpc3RzIGluIG9ubHkgb25lIHBhcnRpdGlvbi4gVXN1YWxseSB3ZSBkb24ndCBjYXJlIGFib3V0XG4gKiB0aGUgcGFydGl0aW9uLCBidXQgd2hlbiB3ZSBuZWVkIHRvIGZvcm0gQVJOcyB3ZSBkby5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY2NvdW50IHtcbiAgLyoqXG4gICAqIFRoZSBhY2NvdW50IG51bWJlclxuICAgKi9cbiAgcmVhZG9ubHkgYWNjb3VudElkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJ0aXRpb24gKCdhd3MnIG9yICdhd3MtY24nIG9yIG90aGVyd2lzZSlcbiAgICovXG4gIHJlYWRvbmx5IHBhcnRpdGlvbjogc3RyaW5nO1xufVxuXG5jb25zdCBERUZBVUxUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDEwMDAwO1xuY29uc3QgREVGQVVMVF9USU1FT1VUID0gMzAwMDAwO1xuXG4vKipcbiAqIEdldCBIVFRQIG9wdGlvbnMgZm9yIHRoZSBTREtcbiAqXG4gKiBSZWFkIGZyb20gdXNlciBpbnB1dCBvciBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogUmV0dXJucyBhIGNvbXBsZXRlIGBDb25maWd1cmF0aW9uT3B0aW9uc2Agb2JqZWN0IGJlY2F1c2UgdGhhdCdzIHdoZXJlXG4gKiBgY3VzdG9tVXNlckFnZW50YCBsaXZlcywgYnV0IGBodHRwT3B0aW9uc2AgaXMgdGhlIG1vc3QgaW1wb3J0YW50IGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VIdHRwT3B0aW9ucyhvcHRpb25zOiBTZGtIdHRwT3B0aW9ucykge1xuICBjb25zdCBjb25maWc6IENvbmZpZ3VyYXRpb25PcHRpb25zID0ge307XG4gIGNvbmZpZy5odHRwT3B0aW9ucyA9IHt9O1xuXG4gIGNvbmZpZy5odHRwT3B0aW9ucy5jb25uZWN0VGltZW91dCA9IERFRkFVTFRfQ09OTkVDVElPTl9USU1FT1VUO1xuICBjb25maWcuaHR0cE9wdGlvbnMudGltZW91dCA9IERFRkFVTFRfVElNRU9VVDtcblxuICBsZXQgdXNlckFnZW50ID0gb3B0aW9ucy51c2VyQWdlbnQ7XG4gIGlmICh1c2VyQWdlbnQgPT0gbnVsbCkge1xuICAgIHVzZXJBZ2VudCA9IGRlZmF1bHRDbGlVc2VyQWdlbnQoKTtcbiAgfVxuICBjb25maWcuY3VzdG9tVXNlckFnZW50ID0gdXNlckFnZW50O1xuXG4gIGNvbnN0IGNhQnVuZGxlUGF0aCA9IG9wdGlvbnMuY2FCdW5kbGVQYXRoIHx8IGNhQnVuZGxlUGF0aEZyb21FbnZpcm9ubWVudCgpO1xuICBpZiAoY2FCdW5kbGVQYXRoKSB7XG4gICAgZGVidWcoJ1VzaW5nIENBIGJ1bmRsZSBwYXRoOiAlcycsIGNhQnVuZGxlUGF0aCk7XG4gICAgKGNvbmZpZy5odHRwT3B0aW9ucyBhcyBhbnkpLmNhID0gcmVhZElmUG9zc2libGUoY2FCdW5kbGVQYXRoKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnByb3h5QWRkcmVzcykge1xuICAgIGRlYnVnKCdQcm94eSBzZXJ2ZXIgZnJvbSBjb21tYW5kLWxpbmUgYXJndW1lbnRzOiAlcycsIG9wdGlvbnMucHJveHlBZGRyZXNzKTtcbiAgfVxuXG4gIC8vIENvbmZpZ3VyZSB0aGUgcHJveHkgYWdlbnQuIEJ5IGRlZmF1bHQsIHRoaXMgd2lsbCB1c2UgSFRUUFM/X1BST1hZIGFuZFxuICAvLyBOT19QUk9YWSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IHRvIHVzZSBmb3IgZWFjaFxuICAvLyByZXF1ZXN0LlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICBjb25zdCBQcm94eUFnZW50ID0gcmVxdWlyZSgncHJveHktYWdlbnQnKTtcbiAgY29uZmlnLmh0dHBPcHRpb25zLmFnZW50ID0gbmV3IFByb3h5QWdlbnQob3B0aW9ucy5wcm94eUFkZHJlc3MpO1xuXG4gIHJldHVybiBjb25maWc7XG59XG5cbi8qKlxuICogRmluZCB0aGUgcGFja2FnZS5qc29uIGZyb20gdGhlIG1haW4gdG9vbGtpdC5cbiAqXG4gKiBJZiB3ZSBjYW4ndCByZWFkIGl0IGZvciBzb21lIHJlYXNvbiwgdHJ5IHRvIGRvIHNvbWV0aGluZyByZWFzb25hYmxlIGFueXdheS5cbiAqIEZhbGwgYmFjayB0byBhcmd2WzFdLCBvciBhIHN0YW5kYXJkIHN0cmluZyBpZiB0aGF0IGlzIHVuZGVmaW5lZCBmb3Igc29tZSByZWFzb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0Q2xpVXNlckFnZW50KCkge1xuICBjb25zdCByb290ID0gcm9vdERpcihmYWxzZSk7XG4gIGNvbnN0IHBrZyA9IEpTT04ucGFyc2UoKHJvb3QgPyByZWFkSWZQb3NzaWJsZShwYXRoLmpvaW4ocm9vdCwgJ3BhY2thZ2UuanNvbicpKSA6IHVuZGVmaW5lZCkgPz8gJ3t9Jyk7XG4gIGNvbnN0IG5hbWUgPSBwa2cubmFtZSA/PyBwYXRoLmJhc2VuYW1lKHByb2Nlc3MuYXJndlsxXSA/PyAnY2RrLWNsaScpO1xuICBjb25zdCB2ZXJzaW9uID0gcGtnLnZlcnNpb24gPz8gJzx1bmtub3duPic7XG4gIHJldHVybiBgJHtuYW1lfS8ke3ZlcnNpb259YDtcbn1cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gYSBDQSBjZXJ0aWZpY2F0ZSBidW5kbGUgcGF0aCB0byBiZSBwYXNzZWQgaW50byB0aGUgU0RLLlxuICovXG5mdW5jdGlvbiBjYUJ1bmRsZVBhdGhGcm9tRW52aXJvbm1lbnQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHByb2Nlc3MuZW52LmF3c19jYV9idW5kbGUpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuYXdzX2NhX2J1bmRsZTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuQVdTX0NBX0JVTkRMRSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5BV1NfQ0FfQlVORExFO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmVhZCBhIGZpbGUgaWYgaXQgZXhpc3RzLCBvciByZXR1cm4gdW5kZWZpbmVkXG4gKlxuICogTm90IGFzeW5jIGJlY2F1c2UgaXQgaXMgdXNlZCBpbiB0aGUgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gcmVhZElmUG9zc2libGUoZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHRyeSB7XG4gICAgaWYgKCFmcy5wYXRoRXhpc3RzU3luYyhmaWxlbmFtZSkpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGRlYnVnKGUpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHVzZXJuYW1lIHdpdGggY2hhcmFjdGVycyBpbnZhbGlkIGZvciBhIFJvbGVTZXNzaW9uTmFtZSByZW1vdmVkXG4gKlxuICogQHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vU1RTL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX0Fzc3VtZVJvbGUuaHRtbCNBUElfQXNzdW1lUm9sZV9SZXF1ZXN0UGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBzYWZlVXNlcm5hbWUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG9zLnVzZXJJbmZvKCkudXNlcm5hbWUucmVwbGFjZSgvW15cXHcrPSwuQC1dL2csICdAJyk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAnbm9uYW1lJztcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIG9idGFpbmluZyBjcmVkZW50aWFscyBmb3IgYW4gZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcmVkZW50aWFsc09wdGlvbnMge1xuICAvKipcbiAgICogVGhlIEFSTiBvZiB0aGUgcm9sZSB0aGF0IG5lZWRzIHRvIGJlIGFzc3VtZWQsIGlmIGFueVxuICAgKi9cbiAgcmVhZG9ubHkgYXNzdW1lUm9sZUFybj86IHN0cmluZztcblxuICAvKipcbiAgICogRXh0ZXJuYWwgSUQgcmVxdWlyZWQgdG8gYXNzdW1lIHRoZSBnaXZlbiByb2xlLlxuICAgKi9cbiAgcmVhZG9ubHkgYXNzdW1lUm9sZUV4dGVybmFsSWQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVzdWx0IG9mIG9idGFpbmluZyBiYXNlIGNyZWRlbnRpYWxzXG4gKi9cbnR5cGUgT2J0YWluQmFzZUNyZWRlbnRpYWxzUmVzdWx0ID1cbiAgeyBzb3VyY2U6ICdjb3JyZWN0RGVmYXVsdCc7IGNyZWRlbnRpYWxzOiBBV1MuQ3JlZGVudGlhbHMgfVxuICB8IHsgc291cmNlOiAncGx1Z2luJzsgcGx1Z2luTmFtZTogc3RyaW5nLCBjcmVkZW50aWFsczogQVdTLkNyZWRlbnRpYWxzIH1cbiAgfCB7IHNvdXJjZTogJ2luY29ycmVjdERlZmF1bHQnOyBjcmVkZW50aWFsczogQVdTLkNyZWRlbnRpYWxzOyBhY2NvdW50SWQ6IHN0cmluZzsgdW51c2VkUGx1Z2luczogc3RyaW5nW10gfVxuICB8IHsgc291cmNlOiAnbm9uZSc7IHVudXNlZFBsdWdpbnM6IHN0cmluZ1tdIH07XG5cbi8qKlxuICogSXNvbGF0aW5nIHRoZSBjb2RlIHRoYXQgdHJhbnNsYXRlcyBjYWxjdWxhdGlvbiBlcnJvcnMgaW50byBodW1hbiBlcnJvciBtZXNzYWdlc1xuICpcbiAqIFdlIGNvdmVyIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gKlxuICogLSBObyBjcmVkZW50aWFscyBhcmUgYXZhaWxhYmxlIGF0IGFsbFxuICogLSBEZWZhdWx0IGNyZWRlbnRpYWxzIGFyZSBmb3IgdGhlIHdyb25nIGFjY291bnRcbiAqL1xuZnVuY3Rpb24gZm10T2J0YWluQ3JlZGVudGlhbHNFcnJvcih0YXJnZXRBY2NvdW50SWQ6IHN0cmluZywgb2J0YWluUmVzdWx0OiBPYnRhaW5CYXNlQ3JlZGVudGlhbHNSZXN1bHQgJiB7IHNvdXJjZTogJ25vbmUnIHwgJ2luY29ycmVjdERlZmF1bHQnIH0pOiBzdHJpbmcge1xuICBjb25zdCBtc2cgPSBbYE5lZWQgdG8gcGVyZm9ybSBBV1MgY2FsbHMgZm9yIGFjY291bnQgJHt0YXJnZXRBY2NvdW50SWR9YF07XG4gIHN3aXRjaCAob2J0YWluUmVzdWx0LnNvdXJjZSkge1xuICAgIGNhc2UgJ2luY29ycmVjdERlZmF1bHQnOlxuICAgICAgbXNnLnB1c2goYGJ1dCB0aGUgY3VycmVudCBjcmVkZW50aWFscyBhcmUgZm9yICR7b2J0YWluUmVzdWx0LmFjY291bnRJZH1gKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ25vbmUnOlxuICAgICAgbXNnLnB1c2goJ2J1dCBubyBjcmVkZW50aWFscyBoYXZlIGJlZW4gY29uZmlndXJlZCcpO1xuICB9XG4gIGlmIChvYnRhaW5SZXN1bHQudW51c2VkUGx1Z2lucy5sZW5ndGggPiAwKSB7XG4gICAgbXNnLnB1c2goYGFuZCBub25lIG9mIHRoZXNlIHBsdWdpbnMgZm91bmQgYW55OiAke29idGFpblJlc3VsdC51bnVzZWRQbHVnaW5zLmpvaW4oJywgJyl9YCk7XG4gIH1cbiAgcmV0dXJuIG1zZy5qb2luKCcsICcpO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIG1lc3NhZ2UgaW5kaWNhdGluZyB3aGVyZSB3ZSBnb3QgYmFzZSBjcmVkZW50aWFscyBmb3IgdGhlIGFzc3VtZSByb2xlXG4gKlxuICogV2UgY292ZXIgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAqXG4gKiAtIERlZmF1bHQgY3JlZGVudGlhbHMgZm9yIHRoZSByaWdodCBhY2NvdW50XG4gKiAtIERlZmF1bHQgY3JlZGVudGlhbHMgZm9yIHRoZSB3cm9uZyBhY2NvdW50XG4gKiAtIENyZWRlbnRpYWxzIHJldHVybmVkIGZyb20gYSBwbHVnaW5cbiAqL1xuZnVuY3Rpb24gZm10T2J0YWluZWRDcmVkZW50aWFscyhcbiAgb2J0YWluUmVzdWx0OiBFeGNsdWRlPE9idGFpbkJhc2VDcmVkZW50aWFsc1Jlc3VsdCwgeyBzb3VyY2U6ICdub25lJyB9Pik6IHN0cmluZyB7XG4gIHN3aXRjaCAob2J0YWluUmVzdWx0LnNvdXJjZSkge1xuICAgIGNhc2UgJ2NvcnJlY3REZWZhdWx0JzpcbiAgICAgIHJldHVybiAnY3VycmVudCBjcmVkZW50aWFscyc7XG4gICAgY2FzZSAncGx1Z2luJzpcbiAgICAgIHJldHVybiBgY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkgcGx1Z2luICcke29idGFpblJlc3VsdC5wbHVnaW5OYW1lfSdgO1xuICAgIGNhc2UgJ2luY29ycmVjdERlZmF1bHQnOlxuICAgICAgY29uc3QgbXNnID0gW107XG4gICAgICBtc2cucHVzaChgY3VycmVudCBjcmVkZW50aWFscyAod2hpY2ggYXJlIGZvciBhY2NvdW50ICR7b2J0YWluUmVzdWx0LmFjY291bnRJZH1gKTtcblxuICAgICAgaWYgKG9idGFpblJlc3VsdC51bnVzZWRQbHVnaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbXNnLnB1c2goYCwgYW5kIG5vbmUgb2YgdGhlIGZvbGxvd2luZyBwbHVnaW5zIHByb3ZpZGVkIGNyZWRlbnRpYWxzOiAke29idGFpblJlc3VsdC51bnVzZWRQbHVnaW5zLmpvaW4oJywgJyl9YCk7XG4gICAgICB9XG4gICAgICBtc2cucHVzaCgnKScpO1xuXG4gICAgICByZXR1cm4gbXNnLmpvaW4oJycpO1xuICB9XG59XG4iXX0=