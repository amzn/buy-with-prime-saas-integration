"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkGraph = void 0;
const parallel_1 = require("./parallel");
const work_graph_types_1 = require("./work-graph-types");
const logging_1 = require("../logging");
class WorkGraph {
    constructor(nodes = {}) {
        this.readyPool = [];
        this.lazyDependencies = new Map();
        this.nodes = { ...nodes };
    }
    addNodes(...nodes) {
        for (const node of nodes) {
            if (this.nodes[node.id]) {
                throw new Error(`Duplicate use of node id: ${node.id}`);
            }
            const ld = this.lazyDependencies.get(node.id);
            if (ld) {
                for (const x of ld) {
                    node.dependencies.add(x);
                }
                this.lazyDependencies.delete(node.id);
            }
            this.nodes[node.id] = node;
        }
    }
    removeNode(nodeId) {
        const id = typeof nodeId === 'string' ? nodeId : nodeId.id;
        const removedNode = this.nodes[id];
        this.lazyDependencies.delete(id);
        delete this.nodes[id];
        if (removedNode) {
            for (const node of Object.values(this.nodes)) {
                node.dependencies.delete(removedNode.id);
            }
        }
    }
    /**
     * Return all nodes of a given type
     */
    nodesOfType(type) {
        return Object.values(this.nodes).filter(n => n.type === type);
    }
    /**
     * Return all nodes that depend on a given node
     */
    dependees(nodeId) {
        const id = typeof nodeId === 'string' ? nodeId : nodeId.id;
        return Object.values(this.nodes).filter(n => n.dependencies.has(id));
    }
    /**
     * Add a dependency, that may come before or after the nodes involved
     */
    addDependency(fromId, toId) {
        const node = this.nodes[fromId];
        if (node) {
            node.dependencies.add(toId);
            return;
        }
        let lazyDeps = this.lazyDependencies.get(fromId);
        if (!lazyDeps) {
            lazyDeps = [];
            this.lazyDependencies.set(fromId, lazyDeps);
        }
        lazyDeps.push(toId);
    }
    tryGetNode(id) {
        return this.nodes[id];
    }
    node(id) {
        const ret = this.nodes[id];
        if (!ret) {
            throw new Error(`No node with id ${id} among ${Object.keys(this.nodes)}`);
        }
        return ret;
    }
    absorb(graph) {
        this.addNodes(...Object.values(graph.nodes));
    }
    hasFailed() {
        return Object.values(this.nodes).some((n) => n.deploymentState === work_graph_types_1.DeploymentState.FAILED);
    }
    doParallel(concurrency, actions) {
        return this.forAllArtifacts(concurrency, async (x) => {
            switch (x.type) {
                case 'stack':
                    await actions.deployStack(x);
                    break;
                case 'asset-build':
                    await actions.buildAsset(x);
                    break;
                case 'asset-publish':
                    await actions.publishAsset(x);
                    break;
            }
        });
    }
    /**
     * Return the set of unblocked nodes
     */
    ready() {
        this.updateReadyPool();
        return this.readyPool;
    }
    forAllArtifacts(n, fn) {
        const graph = this;
        // If 'n' is a number, we limit all concurrency equally (effectively we will be using totalMax)
        // If 'n' is a record, we limit each job independently (effectively we will be using max)
        const max = typeof n === 'number' ?
            {
                'asset-build': n,
                'asset-publish': n,
                'stack': n,
            } : n;
        const totalMax = typeof n === 'number' ? n : sum(Object.values(n));
        return new Promise((ok, fail) => {
            let active = {
                'asset-build': 0,
                'asset-publish': 0,
                'stack': 0,
            };
            function totalActive() {
                return sum(Object.values(active));
            }
            start();
            function start() {
                graph.updateReadyPool();
                for (let i = 0; i < graph.readyPool.length;) {
                    const node = graph.readyPool[i];
                    if (active[node.type] < max[node.type] && totalActive() < totalMax) {
                        graph.readyPool.splice(i, 1);
                        startOne(node);
                    }
                    else {
                        i += 1;
                    }
                }
                if (totalActive() === 0) {
                    if (graph.done()) {
                        ok();
                    }
                    // wait for other active deploys to finish before failing
                    if (graph.hasFailed()) {
                        fail(graph.error);
                    }
                }
            }
            function startOne(x) {
                x.deploymentState = work_graph_types_1.DeploymentState.DEPLOYING;
                active[x.type]++;
                void fn(x)
                    .finally(() => {
                    active[x.type]--;
                })
                    .then(() => {
                    graph.deployed(x);
                    start();
                }).catch((err) => {
                    // By recording the failure immediately as the queued task exits, we prevent the next
                    // queued task from starting.
                    graph.failed(x, err);
                    start();
                });
            }
        });
    }
    done() {
        return Object.values(this.nodes).every((n) => work_graph_types_1.DeploymentState.COMPLETED === n.deploymentState);
    }
    deployed(node) {
        node.deploymentState = work_graph_types_1.DeploymentState.COMPLETED;
    }
    failed(node, error) {
        this.error = error;
        node.deploymentState = work_graph_types_1.DeploymentState.FAILED;
        this.skipRest();
        this.readyPool.splice(0);
    }
    toString() {
        return [
            'digraph D {',
            ...Object.entries(this.nodes).flatMap(([id, node]) => renderNode(id, node)),
            '}',
        ].join('\n');
        function renderNode(id, node) {
            const ret = [];
            if (node.deploymentState === work_graph_types_1.DeploymentState.COMPLETED) {
                ret.push(`  "${simplifyId(id)}" [style=filled,fillcolor=yellow];`);
            }
            else {
                ret.push(`  "${simplifyId(id)}";`);
            }
            for (const dep of node.dependencies) {
                ret.push(`  "${simplifyId(id)}" -> "${simplifyId(dep)}";`);
            }
            return ret;
        }
        function simplifyId(id) {
            return id.replace(/([0-9a-f]{6})[0-9a-f]{6,}/g, '$1');
        }
    }
    /**
     * Ensure all dependencies actually exist. This protects against scenarios such as the following:
     * StackA depends on StackB, but StackB is not selected to deploy. The dependency is redundant
     * and will be dropped.
     * This assumes the manifest comes uncorrupted so we will not fail if a dependency is not found.
     */
    removeUnavailableDependencies() {
        for (const node of Object.values(this.nodes)) {
            const removeDeps = Array.from(node.dependencies).filter((dep) => this.nodes[dep] === undefined);
            removeDeps.forEach((d) => {
                node.dependencies.delete(d);
            });
        }
    }
    /**
     * Remove all asset publishing steps for assets that are already published, and then build
     * that aren't used anymore.
     *
     * Do this in parallel, because there may be a lot of assets in an application (seen in practice: >100 assets)
     */
    async removeUnnecessaryAssets(isUnnecessary) {
        (0, logging_1.debug)('Checking for previously published assets');
        const publishes = this.nodesOfType('asset-publish');
        const classifiedNodes = await (0, parallel_1.parallelPromises)(8, publishes.map((assetNode) => async () => [assetNode, await isUnnecessary(assetNode)]));
        const alreadyPublished = classifiedNodes.filter(([_, unnecessary]) => unnecessary).map(([assetNode, _]) => assetNode);
        for (const assetNode of alreadyPublished) {
            this.removeNode(assetNode);
        }
        (0, logging_1.debug)(`${publishes.length} total assets, ${publishes.length - alreadyPublished.length} still need to be published`);
        // Now also remove any asset build steps that don't have any dependencies on them anymore
        const unusedBuilds = this.nodesOfType('asset-build').filter(build => this.dependees(build).length === 0);
        for (const unusedBuild of unusedBuilds) {
            this.removeNode(unusedBuild);
        }
    }
    updateReadyPool() {
        const activeCount = Object.values(this.nodes).filter((x) => x.deploymentState === work_graph_types_1.DeploymentState.DEPLOYING).length;
        const pendingCount = Object.values(this.nodes).filter((x) => x.deploymentState === work_graph_types_1.DeploymentState.PENDING).length;
        const newlyReady = Object.values(this.nodes).filter((x) => x.deploymentState === work_graph_types_1.DeploymentState.PENDING &&
            Array.from(x.dependencies).every((id) => this.node(id).deploymentState === work_graph_types_1.DeploymentState.COMPLETED));
        // Add newly available nodes to the ready pool
        for (const node of newlyReady) {
            node.deploymentState = work_graph_types_1.DeploymentState.QUEUED;
            this.readyPool.push(node);
        }
        // Remove nodes from the ready pool that have already started deploying
        retainOnly(this.readyPool, (node) => node.deploymentState === work_graph_types_1.DeploymentState.QUEUED);
        // Sort by reverse priority
        this.readyPool.sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
        if (this.readyPool.length === 0 && activeCount === 0 && pendingCount > 0) {
            const cycle = this.findCycle() ?? ['No cycle found!'];
            (0, logging_1.trace)(`Cycle ${cycle.join(' -> ')} in graph ${this}`);
            throw new Error(`Unable to make progress anymore, dependency cycle between remaining artifacts: ${cycle.join(' -> ')} (run with -vv for full graph)`);
        }
    }
    skipRest() {
        for (const node of Object.values(this.nodes)) {
            if ([work_graph_types_1.DeploymentState.QUEUED, work_graph_types_1.DeploymentState.PENDING].includes(node.deploymentState)) {
                node.deploymentState = work_graph_types_1.DeploymentState.SKIPPED;
            }
        }
    }
    /**
     * Find cycles in a graph
     *
     * Not the fastest, but effective and should be rare
     */
    findCycle() {
        const seen = new Set();
        const self = this;
        for (const nodeId of Object.keys(this.nodes)) {
            const cycle = recurse(nodeId, [nodeId]);
            if (cycle) {
                return cycle;
            }
        }
        return undefined;
        function recurse(nodeId, path) {
            if (seen.has(nodeId)) {
                return undefined;
            }
            try {
                for (const dep of self.nodes[nodeId].dependencies ?? []) {
                    const index = path.indexOf(dep);
                    if (index > -1) {
                        return [...path.slice(index), dep];
                    }
                    const cycle = recurse(dep, [...path, dep]);
                    if (cycle) {
                        return cycle;
                    }
                }
                return undefined;
            }
            finally {
                seen.add(nodeId);
            }
        }
    }
    /**
     * Whether the `end` node is reachable from the `start` node, following the dependency arrows
     */
    reachable(start, end) {
        const seen = new Set();
        const self = this;
        return recurse(start);
        function recurse(current) {
            if (seen.has(current)) {
                return false;
            }
            seen.add(current);
            if (current === end) {
                return true;
            }
            for (const dep of self.nodes[current].dependencies) {
                if (recurse(dep)) {
                    return true;
                }
            }
            return false;
        }
    }
}
exports.WorkGraph = WorkGraph;
function sum(xs) {
    let ret = 0;
    for (const x of xs) {
        ret += x;
    }
    return ret;
}
function retainOnly(xs, pred) {
    xs.splice(0, xs.length, ...xs.filter(pred));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29yay1ncmFwaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIndvcmstZ3JhcGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseUNBQThDO0FBQzlDLHlEQUE0RztBQUM1Ryx3Q0FBMEM7QUFJMUMsTUFBYSxTQUFTO0lBTXBCLFlBQW1CLFFBQWtDLEVBQUU7UUFKdEMsY0FBUyxHQUFvQixFQUFFLENBQUM7UUFDaEMscUJBQWdCLEdBQUcsSUFBSSxHQUFHLEVBQW9CLENBQUM7UUFJOUQsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUcsS0FBSyxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVNLFFBQVEsQ0FBQyxHQUFHLEtBQWlCO1FBQ2xDLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO1lBQ3hCLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUU7Z0JBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2FBQ3pEO1lBRUQsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDOUMsSUFBSSxFQUFFLEVBQUU7Z0JBQ04sS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUU7b0JBQ2xCLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUMxQjtnQkFDRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUN2QztZQUVELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztTQUM1QjtJQUNILENBQUM7SUFFTSxVQUFVLENBQUMsTUFBeUI7UUFDekMsTUFBTSxFQUFFLEdBQUcsT0FBTyxNQUFNLEtBQUssUUFBUSxD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Q0FBQztBQUVELFNBQVMsVUFBVSxDQUFJLEVBQU8sRUFBRSxJQUF1QjtJQUNyRCxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzlDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJhbGxlbFByb21pc2VzIH0gZnJvbSAnLi9wYXJhbGxlbCc7XG5pbXBvcnQgeyBXb3JrTm9kZSwgRGVwbG95bWVudFN0YXRlLCBTdGFja05vZGUsIEFzc2V0QnVpbGROb2RlLCBBc3NldFB1Ymxpc2hOb2RlIH0gZnJvbSAnLi93b3JrLWdyYXBoLXR5cGVzJztcbmltcG9ydCB7IGRlYnVnLCB0cmFjZSB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuXG5leHBvcnQgdHlwZSBDb25jdXJyZW5jeSA9IG51bWJlciB8IFJlY29yZDxXb3JrTm9kZVsndHlwZSddLCBudW1iZXI+O1xuXG5leHBvcnQgY2xhc3MgV29ya0dyYXBoIHtcbiAgcHVibGljIHJlYWRvbmx5IG5vZGVzOiBSZWNvcmQ8c3RyaW5nLCBXb3JrTm9kZT47XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVhZHlQb29sOiBBcnJheTxXb3JrTm9kZT4gPSBbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBsYXp5RGVwZW5kZW5jaWVzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZ1tdPigpO1xuICBwdWJsaWMgZXJyb3I/OiBFcnJvcjtcblxuICBwdWJsaWMgY29uc3RydWN0b3Iobm9kZXM6IFJlY29yZDxzdHJpbmcsIFdvcmtOb2RlPiA9IHt9KSB7XG4gICAgdGhpcy5ub2RlcyA9IHsgLi4ubm9kZXMgfTtcbiAgfVxuXG4gIHB1YmxpYyBhZGROb2RlcyguLi5ub2RlczogV29ya05vZGVbXSkge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgaWYgKHRoaXMubm9kZXNbbm9kZS5pZF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgdXNlIG9mIG5vZGUgaWQ6ICR7bm9kZS5pZH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGQgPSB0aGlzLmxhenlEZXBlbmRlbmNpZXMuZ2V0KG5vZGUuaWQpO1xuICAgICAgaWYgKGxkKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiBsZCkge1xuICAgICAgICAgIG5vZGUuZGVwZW5kZW5jaWVzLmFkZCh4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhenlEZXBlbmRlbmNpZXMuZGVsZXRlKG5vZGUuaWQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5vZGVzW25vZGUuaWRdID0gbm9kZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlTm9kZShub2RlSWQ6IHN0cmluZyB8IFdvcmtOb2RlKSB7XG4gICAgY29uc3QgaWQgPSB0eXBlb2Ygbm9kZUlkID09PSAnc3RyaW5nJyA/IG5vZGVJZCA6IG5vZGVJZC5pZDtcbiAgICBjb25zdCByZW1vdmVkTm9kZSA9IHRoaXMubm9kZXNbaWRdO1xuXG4gICAgdGhpcy5sYXp5RGVwZW5kZW5jaWVzLmRlbGV0ZShpZCk7XG4gICAgZGVsZXRlIHRoaXMubm9kZXNbaWRdO1xuXG4gICAgaWYgKHJlbW92ZWROb2RlKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKSkge1xuICAgICAgICBub2RlLmRlcGVuZGVuY2llcy5kZWxldGUocmVtb3ZlZE5vZGUuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIG5vZGVzIG9mIGEgZ2l2ZW4gdHlwZVxuICAgKi9cbiAgcHVibGljIG5vZGVzT2ZUeXBlPFQgZXh0ZW5kcyBXb3JrTm9kZVsndHlwZSddPih0eXBlOiBUKTogRXh0cmFjdDxXb3JrTm9kZSwgeyB0eXBlOiBUIH0+W10ge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLmZpbHRlcihuID0+IG4udHlwZSA9PT0gdHlwZSkgYXMgYW55O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgbm9kZXMgdGhhdCBkZXBlbmQgb24gYSBnaXZlbiBub2RlXG4gICAqL1xuICBwdWJsaWMgZGVwZW5kZWVzKG5vZGVJZDogc3RyaW5nIHwgV29ya05vZGUpIHtcbiAgICBjb25zdCBpZCA9IHR5cGVvZiBub2RlSWQgPT09ICdzdHJpbmcnID8gbm9kZUlkIDogbm9kZUlkLmlkO1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLmZpbHRlcihuID0+IG4uZGVwZW5kZW5jaWVzLmhhcyhpZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGRlcGVuZGVuY3ksIHRoYXQgbWF5IGNvbWUgYmVmb3JlIG9yIGFmdGVyIHRoZSBub2RlcyBpbnZvbHZlZFxuICAgKi9cbiAgcHVibGljIGFkZERlcGVuZGVuY3koZnJvbUlkOiBzdHJpbmcsIHRvSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVzW2Zyb21JZF07XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGUuZGVwZW5kZW5jaWVzLmFkZCh0b0lkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGxhenlEZXBzID0gdGhpcy5sYXp5RGVwZW5kZW5jaWVzLmdldChmcm9tSWQpO1xuICAgIGlmICghbGF6eURlcHMpIHtcbiAgICAgIGxhenlEZXBzID0gW107XG4gICAgICB0aGlzLmxhenlEZXBlbmRlbmNpZXMuc2V0KGZyb21JZCwgbGF6eURlcHMpO1xuICAgIH1cbiAgICBsYXp5RGVwcy5wdXNoKHRvSWQpO1xuICB9XG5cbiAgcHVibGljIHRyeUdldE5vZGUoaWQ6IHN0cmluZyk6IFdvcmtOb2RlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc1tpZF07XG4gIH1cblxuICBwdWJsaWMgbm9kZShpZDogc3RyaW5nKSB7XG4gICAgY29uc3QgcmV0ID0gdGhpcy5ub2Rlc1tpZF07XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbm9kZSB3aXRoIGlkICR7aWR9IGFtb25nICR7T2JqZWN0LmtleXModGhpcy5ub2Rlcyl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBwdWJsaWMgYWJzb3JiKGdyYXBoOiBXb3JrR3JhcGgpIHtcbiAgICB0aGlzLmFkZE5vZGVzKC4uLk9iamVjdC52YWx1ZXMoZ3JhcGgubm9kZXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFzRmFpbGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLnNvbWUoKG4pID0+IG4uZGVwbG95bWVudFN0YXRlID09PSBEZXBsb3ltZW50U3RhdGUuRkFJTEVEKTtcbiAgfVxuXG4gIHB1YmxpYyBkb1BhcmFsbGVsKGNvbmN1cnJlbmN5OiBDb25jdXJyZW5jeSwgYWN0aW9uczogV29ya0dyYXBoQWN0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmZvckFsbEFydGlmYWN0cyhjb25jdXJyZW5jeSwgYXN5bmMgKHg6IFdvcmtOb2RlKSA9PiB7XG4gICAgICBzd2l0Y2ggKHgudHlwZSkge1xuICAgICAgICBjYXNlICdzdGFjayc6XG4gICAgICAgICAgYXdhaXQgYWN0aW9ucy5kZXBsb3lTdGFjayh4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXNzZXQtYnVpbGQnOlxuICAgICAgICAgIGF3YWl0IGFjdGlvbnMuYnVpbGRBc3NldCh4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXNzZXQtcHVibGlzaCc6XG4gICAgICAgICAgYXdhaXQgYWN0aW9ucy5wdWJsaXNoQXNzZXQoeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzZXQgb2YgdW5ibG9ja2VkIG5vZGVzXG4gICAqL1xuICBwdWJsaWMgcmVhZHkoKTogUmVhZG9ubHlBcnJheTxXb3JrTm9kZT4ge1xuICAgIHRoaXMudXBkYXRlUmVhZHlQb29sKCk7XG4gICAgcmV0dXJuIHRoaXMucmVhZHlQb29sO1xuICB9XG5cbiAgcHJpdmF0ZSBmb3JBbGxBcnRpZmFjdHMobjogQ29uY3VycmVuY3ksIGZuOiAoeDogV29ya05vZGUpID0+IFByb21pc2U8dm9pZD4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBncmFwaCA9IHRoaXM7XG5cbiAgICAvLyBJZiAnbicgaXMgYSBudW1iZXIsIHdlIGxpbWl0IGFsbCBjb25jdXJyZW5jeSBlcXVhbGx5IChlZmZlY3RpdmVseSB3ZSB3aWxsIGJlIHVzaW5nIHRvdGFsTWF4KVxuICAgIC8vIElmICduJyBpcyBhIHJlY29yZCwgd2UgbGltaXQgZWFjaCBqb2IgaW5kZXBlbmRlbnRseSAoZWZmZWN0aXZlbHkgd2Ugd2lsbCBiZSB1c2luZyBtYXgpXG4gICAgY29uc3QgbWF4OiBSZWNvcmQ8V29ya05vZGVbJ3R5cGUnXSwgbnVtYmVyPiA9IHR5cGVvZiBuID09PSAnbnVtYmVyJyA/XG4gICAgICB7XG4gICAgICAgICdhc3NldC1idWlsZCc6IG4sXG4gICAgICAgICdhc3NldC1wdWJsaXNoJzogbixcbiAgICAgICAgJ3N0YWNrJzogbixcbiAgICAgIH0gOiBuO1xuICAgIGNvbnN0IHRvdGFsTWF4ID0gdHlwZW9mIG4gPT09ICdudW1iZXInID8gbiA6IHN1bShPYmplY3QudmFsdWVzKG4pKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgob2ssIGZhaWwpID0+IHtcbiAgICAgIGxldCBhY3RpdmU6IFJlY29yZDxXb3JrTm9kZVsndHlwZSddLCBudW1iZXI+ID0ge1xuICAgICAgICAnYXNzZXQtYnVpbGQnOiAwLFxuICAgICAgICAnYXNzZXQtcHVibGlzaCc6IDAsXG4gICAgICAgICdzdGFjayc6IDAsXG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gdG90YWxBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiBzdW0oT2JqZWN0LnZhbHVlcyhhY3RpdmUpKTtcbiAgICAgIH1cblxuICAgICAgc3RhcnQoKTtcblxuICAgICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIGdyYXBoLnVwZGF0ZVJlYWR5UG9vbCgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGgucmVhZHlQb29sLmxlbmd0aDsgKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IGdyYXBoLnJlYWR5UG9vbFtpXTtcblxuICAgICAgICAgIGlmIChhY3RpdmVbbm9kZS50eXBlXSA8IG1heFtub2RlLnR5cGVdICYmIHRvdGFsQWN0aXZlKCkgPCB0b3RhbE1heCkge1xuICAgICAgICAgICAgZ3JhcGgucmVhZHlQb29sLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHN0YXJ0T25lKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvdGFsQWN0aXZlKCkgPT09IDApIHtcbiAgICAgICAgICBpZiAoZ3JhcGguZG9uZSgpKSB7XG4gICAgICAgICAgICBvaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3YWl0IGZvciBvdGhlciBhY3RpdmUgZGVwbG95cyB0byBmaW5pc2ggYmVmb3JlIGZhaWxpbmdcbiAgICAgICAgICBpZiAoZ3JhcGguaGFzRmFpbGVkKCkpIHtcbiAgICAgICAgICAgIGZhaWwoZ3JhcGguZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGFydE9uZSh4OiBXb3JrTm9kZSkge1xuICAgICAgICB4LmRlcGxveW1lbnRTdGF0ZSA9IERlcGxveW1lbnRTdGF0ZS5ERVBMT1lJTkc7XG4gICAgICAgIGFjdGl2ZVt4LnR5cGVdKys7XG4gICAgICAgIHZvaWQgZm4oeClcbiAgICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBhY3RpdmVbeC50eXBlXS0tO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZ3JhcGguZGVwbG95ZWQoeCk7XG4gICAgICAgICAgICBzdGFydCgpO1xuICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIC8vIEJ5IHJlY29yZGluZyB0aGUgZmFpbHVyZSBpbW1lZGlhdGVseSBhcyB0aGUgcXVldWVkIHRhc2sgZXhpdHMsIHdlIHByZXZlbnQgdGhlIG5leHRcbiAgICAgICAgICAgIC8vIHF1ZXVlZCB0YXNrIGZyb20gc3RhcnRpbmcuXG4gICAgICAgICAgICBncmFwaC5mYWlsZWQoeCwgZXJyKTtcbiAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGRvbmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykuZXZlcnkoKG4pID0+IERlcGxveW1lbnRTdGF0ZS5DT01QTEVURUQgPT09IG4uZGVwbG95bWVudFN0YXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgZGVwbG95ZWQobm9kZTogV29ya05vZGUpIHtcbiAgICBub2RlLmRlcGxveW1lbnRTdGF0ZSA9IERlcGxveW1lbnRTdGF0ZS5DT01QTEVURUQ7XG4gIH1cblxuICBwcml2YXRlIGZhaWxlZChub2RlOiBXb3JrTm9kZSwgZXJyb3I/OiBFcnJvcikge1xuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICBub2RlLmRlcGxveW1lbnRTdGF0ZSA9IERlcGxveW1lbnRTdGF0ZS5GQUlMRUQ7XG4gICAgdGhpcy5za2lwUmVzdCgpO1xuICAgIHRoaXMucmVhZHlQb29sLnNwbGljZSgwKTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ2RpZ3JhcGggRCB7JyxcbiAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHRoaXMubm9kZXMpLmZsYXRNYXAoKFtpZCwgbm9kZV0pID0+IHJlbmRlck5vZGUoaWQsIG5vZGUpKSxcbiAgICAgICd9JyxcbiAgICBdLmpvaW4oJ1xcbicpO1xuXG4gICAgZnVuY3Rpb24gcmVuZGVyTm9kZShpZDogc3RyaW5nLCBub2RlOiBXb3JrTm9kZSk6IHN0cmluZ1tdIHtcbiAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgaWYgKG5vZGUuZGVwbG95bWVudFN0YXRlID09PSBEZXBsb3ltZW50U3RhdGUuQ09NUExFVEVEKSB7XG4gICAgICAgIHJldC5wdXNoKGAgIFwiJHtzaW1wbGlmeUlkKGlkKX1cIiBbc3R5bGU9ZmlsbGVkLGZpbGxjb2xvcj15ZWxsb3ddO2ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LnB1c2goYCAgXCIke3NpbXBsaWZ5SWQoaWQpfVwiO2ApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBkZXAgb2Ygbm9kZS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgcmV0LnB1c2goYCAgXCIke3NpbXBsaWZ5SWQoaWQpfVwiIC0+IFwiJHtzaW1wbGlmeUlkKGRlcCl9XCI7YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpbXBsaWZ5SWQoaWQ6IHN0cmluZykge1xuICAgICAgcmV0dXJuIGlkLnJlcGxhY2UoLyhbMC05YS1mXXs2fSlbMC05YS1mXXs2LH0vZywgJyQxJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBhbGwgZGVwZW5kZW5jaWVzIGFjdHVhbGx5IGV4aXN0LiBUaGlzIHByb3RlY3RzIGFnYWluc3Qgc2NlbmFyaW9zIHN1Y2ggYXMgdGhlIGZvbGxvd2luZzpcbiAgICogU3RhY2tBIGRlcGVuZHMgb24gU3RhY2tCLCBidXQgU3RhY2tCIGlzIG5vdCBzZWxlY3RlZCB0byBkZXBsb3kuIFRoZSBkZXBlbmRlbmN5IGlzIHJlZHVuZGFudFxuICAgKiBhbmQgd2lsbCBiZSBkcm9wcGVkLlxuICAgKiBUaGlzIGFzc3VtZXMgdGhlIG1hbmlmZXN0IGNvbWVzIHVuY29ycnVwdGVkIHNvIHdlIHdpbGwgbm90IGZhaWwgaWYgYSBkZXBlbmRlbmN5IGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIHB1YmxpYyByZW1vdmVVbmF2YWlsYWJsZURlcGVuZGVuY2llcygpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKSkge1xuICAgICAgY29uc3QgcmVtb3ZlRGVwcyA9IEFycmF5LmZyb20obm9kZS5kZXBlbmRlbmNpZXMpLmZpbHRlcigoZGVwKSA9PiB0aGlzLm5vZGVzW2RlcF0gPT09IHVuZGVmaW5lZCk7XG5cbiAgICAgIHJlbW92ZURlcHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBub2RlLmRlcGVuZGVuY2llcy5kZWxldGUoZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBhc3NldCBwdWJsaXNoaW5nIHN0ZXBzIGZvciBhc3NldHMgdGhhdCBhcmUgYWxyZWFkeSBwdWJsaXNoZWQsIGFuZCB0aGVuIGJ1aWxkXG4gICAqIHRoYXQgYXJlbid0IHVzZWQgYW55bW9yZS5cbiAgICpcbiAgICogRG8gdGhpcyBpbiBwYXJhbGxlbCwgYmVjYXVzZSB0aGVyZSBtYXkgYmUgYSBsb3Qgb2YgYXNzZXRzIGluIGFuIGFwcGxpY2F0aW9uIChzZWVuIGluIHByYWN0aWNlOiA+MTAwIGFzc2V0cylcbiAgICovXG4gIHB1YmxpYyBhc3luYyByZW1vdmVVbm5lY2Vzc2FyeUFzc2V0cyhpc1VubmVjZXNzYXJ5OiAoeDogQXNzZXRQdWJsaXNoTm9kZSkgPT4gUHJvbWlzZTxib29sZWFuPikge1xuICAgIGRlYnVnKCdDaGVja2luZyBmb3IgcHJldmlvdXNseSBwdWJsaXNoZWQgYXNzZXRzJyk7XG5cbiAgICBjb25zdCBwdWJsaXNoZXMgPSB0aGlzLm5vZGVzT2ZUeXBlKCdhc3NldC1wdWJsaXNoJyk7XG5cbiAgICBjb25zdCBjbGFzc2lmaWVkTm9kZXMgPSBhd2FpdCBwYXJhbGxlbFByb21pc2VzKFxuICAgICAgOCxcbiAgICAgIHB1Ymxpc2hlcy5tYXAoKGFzc2V0Tm9kZSkgPT4gYXN5bmMoKSA9PiBbYXNzZXROb2RlLCBhd2FpdCBpc1VubmVjZXNzYXJ5KGFzc2V0Tm9kZSldIGFzIGNvbnN0KSk7XG5cbiAgICBjb25zdCBhbHJlYWR5UHVibGlzaGVkID0gY2xhc3NpZmllZE5vZGVzLmZpbHRlcigoW18sIHVubmVjZXNzYXJ5XSkgPT4gdW5uZWNlc3NhcnkpLm1hcCgoW2Fzc2V0Tm9kZSwgX10pID0+IGFzc2V0Tm9kZSk7XG4gICAgZm9yIChjb25zdCBhc3NldE5vZGUgb2YgYWxyZWFkeVB1Ymxpc2hlZCkge1xuICAgICAgdGhpcy5yZW1vdmVOb2RlKGFzc2V0Tm9kZSk7XG4gICAgfVxuXG4gICAgZGVidWcoYCR7cHVibGlzaGVzLmxlbmd0aH0gdG90YWwgYXNzZXRzLCAke3B1Ymxpc2hlcy5sZW5ndGggLSBhbHJlYWR5UHVibGlzaGVkLmxlbmd0aH0gc3RpbGwgbmVlZCB0byBiZSBwdWJsaXNoZWRgKTtcblxuICAgIC8vIE5vdyBhbHNvIHJlbW92ZSBhbnkgYXNzZXQgYnVpbGQgc3RlcHMgdGhhdCBkb24ndCBoYXZlIGFueSBkZXBlbmRlbmNpZXMgb24gdGhlbSBhbnltb3JlXG4gICAgY29uc3QgdW51c2VkQnVpbGRzID0gdGhpcy5ub2Rlc09mVHlwZSgnYXNzZXQtYnVpbGQnKS5maWx0ZXIoYnVpbGQgPT4gdGhpcy5kZXBlbmRlZXMoYnVpbGQpLmxlbmd0aCA9PT0gMCk7XG4gICAgZm9yIChjb25zdCB1bnVzZWRCdWlsZCBvZiB1bnVzZWRCdWlsZHMpIHtcbiAgICAgIHRoaXMucmVtb3ZlTm9kZSh1bnVzZWRCdWlsZCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVSZWFkeVBvb2woKSB7XG4gICAgY29uc3QgYWN0aXZlQ291bnQgPSBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLmZpbHRlcigoeCkgPT4geC5kZXBsb3ltZW50U3RhdGUgPT09IERlcGxveW1lbnRTdGF0ZS5ERVBMT1lJTkcpLmxlbmd0aDtcbiAgICBjb25zdCBwZW5kaW5nQ291bnQgPSBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLmZpbHRlcigoeCkgPT4geC5kZXBsb3ltZW50U3RhdGUgPT09IERlcGxveW1lbnRTdGF0ZS5QRU5ESU5HKS5sZW5ndGg7XG5cbiAgICBjb25zdCBuZXdseVJlYWR5ID0gT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5maWx0ZXIoKHgpID0+XG4gICAgICB4LmRlcGxveW1lbnRTdGF0ZSA9PT0gRGVwbG95bWVudFN0YXRlLlBFTkRJTkcgJiZcbiAgICAgIEFycmF5LmZyb20oeC5kZXBlbmRlbmNpZXMpLmV2ZXJ5KChpZCkgPT4gdGhpcy5ub2RlKGlkKS5kZXBsb3ltZW50U3RhdGUgPT09IERlcGxveW1lbnRTdGF0ZS5DT01QTEVURUQpKTtcblxuICAgIC8vIEFkZCBuZXdseSBhdmFpbGFibGUgbm9kZXMgdG8gdGhlIHJlYWR5IHBvb2xcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgbmV3bHlSZWFkeSkge1xuICAgICAgbm9kZS5kZXBsb3ltZW50U3RhdGUgPSBEZXBsb3ltZW50U3RhdGUuUVVFVUVEO1xuICAgICAgdGhpcy5yZWFkeVBvb2wucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgbm9kZXMgZnJvbSB0aGUgcmVhZHkgcG9vbCB0aGF0IGhhdmUgYWxyZWFkeSBzdGFydGVkIGRlcGxveWluZ1xuICAgIHJldGFpbk9ubHkodGhpcy5yZWFkeVBvb2wsIChub2RlKSA9PiBub2RlLmRlcGxveW1lbnRTdGF0ZSA9PT0gRGVwbG95bWVudFN0YXRlLlFVRVVFRCk7XG5cbiAgICAvLyBTb3J0IGJ5IHJldmVyc2UgcHJpb3JpdHlcbiAgICB0aGlzLnJlYWR5UG9vbC5zb3J0KChhLCBiKSA9PiAoYi5wcmlvcml0eSA/PyAwKSAtIChhLnByaW9yaXR5ID8/IDApKTtcblxuICAgIGlmICh0aGlzLnJlYWR5UG9vbC5sZW5ndGggPT09IDAgJiYgYWN0aXZlQ291bnQgPT09IDAgJiYgcGVuZGluZ0NvdW50ID4gMCkge1xuICAgICAgY29uc3QgY3ljbGUgPSB0aGlzLmZpbmRDeWNsZSgpID8/IFsnTm8gY3ljbGUgZm91bmQhJ107XG4gICAgICB0cmFjZShgQ3ljbGUgJHtjeWNsZS5qb2luKCcgLT4gJyl9IGluIGdyYXBoICR7dGhpc31gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIG1ha2UgcHJvZ3Jlc3MgYW55bW9yZSwgZGVwZW5kZW5jeSBjeWNsZSBiZXR3ZWVuIHJlbWFpbmluZyBhcnRpZmFjdHM6ICR7Y3ljbGUuam9pbignIC0+ICcpfSAocnVuIHdpdGggLXZ2IGZvciBmdWxsIGdyYXBoKWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2tpcFJlc3QoKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykpIHtcbiAgICAgIGlmIChbRGVwbG95bWVudFN0YXRlLlFVRVVFRCwgRGVwbG95bWVudFN0YXRlLlBFTkRJTkddLmluY2x1ZGVzKG5vZGUuZGVwbG95bWVudFN0YXRlKSkge1xuICAgICAgICBub2RlLmRlcGxveW1lbnRTdGF0ZSA9IERlcGxveW1lbnRTdGF0ZS5TS0lQUEVEO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGN5Y2xlcyBpbiBhIGdyYXBoXG4gICAqXG4gICAqIE5vdCB0aGUgZmFzdGVzdCwgYnV0IGVmZmVjdGl2ZSBhbmQgc2hvdWxkIGJlIHJhcmVcbiAgICovXG4gIHB1YmxpYyBmaW5kQ3ljbGUoKTogc3RyaW5nW10gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IG5vZGVJZCBvZiBPYmplY3Qua2V5cyh0aGlzLm5vZGVzKSkge1xuICAgICAgY29uc3QgY3ljbGUgPSByZWN1cnNlKG5vZGVJZCwgW25vZGVJZF0pO1xuICAgICAgaWYgKGN5Y2xlKSB7IHJldHVybiBjeWNsZTsgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgZnVuY3Rpb24gcmVjdXJzZShub2RlSWQ6IHN0cmluZywgcGF0aDogc3RyaW5nW10pOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB7XG4gICAgICBpZiAoc2Vlbi5oYXMobm9kZUlkKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChjb25zdCBkZXAgb2Ygc2VsZi5ub2Rlc1tub2RlSWRdLmRlcGVuZGVuY2llcyA/PyBbXSkge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGF0aC5pbmRleE9mKGRlcCk7XG4gICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4ucGF0aC5zbGljZShpbmRleCksIGRlcF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY3ljbGUgPSByZWN1cnNlKGRlcCwgWy4uLnBhdGgsIGRlcF0pO1xuICAgICAgICAgIGlmIChjeWNsZSkgeyByZXR1cm4gY3ljbGU7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZWVuLmFkZChub2RlSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBgZW5kYCBub2RlIGlzIHJlYWNoYWJsZSBmcm9tIHRoZSBgc3RhcnRgIG5vZGUsIGZvbGxvd2luZyB0aGUgZGVwZW5kZW5jeSBhcnJvd3NcbiAgICovXG4gIHB1YmxpYyByZWFjaGFibGUoc3RhcnQ6IHN0cmluZywgZW5kOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHJlY3Vyc2Uoc3RhcnQpO1xuXG4gICAgZnVuY3Rpb24gcmVjdXJzZShjdXJyZW50OiBzdHJpbmcpIHtcbiAgICAgIGlmIChzZWVuLmhhcyhjdXJyZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzZWVuLmFkZChjdXJyZW50KTtcblxuICAgICAgaWYgKGN1cnJlbnQgPT09IGVuZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIHNlbGYubm9kZXNbY3VycmVudF0uZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmIChyZWN1cnNlKGRlcCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtHcmFwaEFjdGlvbnMge1xuICBkZXBsb3lTdGFjazogKHN0YWNrTm9kZTogU3RhY2tOb2RlKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBidWlsZEFzc2V0OiAoYXNzZXROb2RlOiBBc3NldEJ1aWxkTm9kZSkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcHVibGlzaEFzc2V0OiAoYXNzZXROb2RlOiBBc3NldFB1Ymxpc2hOb2RlKSA9PiBQcm9taXNlPHZvaWQ+O1xufVxuXG5mdW5jdGlvbiBzdW0oeHM6IG51bWJlcltdKSB7XG4gIGxldCByZXQgPSAwO1xuICBmb3IgKGNvbnN0IHggb2YgeHMpIHtcbiAgICByZXQgKz0geDtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiByZXRhaW5Pbmx5PEE+KHhzOiBBW10sIHByZWQ6ICh4OiBBKSA9PiBib29sZWFuKSB7XG4gIHhzLnNwbGljZSgwLCB4cy5sZW5ndGgsIC4uLnhzLmZpbHRlcihwcmVkKSk7XG59XG4iXX0=